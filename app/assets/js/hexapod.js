(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["hexapod"] = factory();
	else
		root["hexapod"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/walkingGaits.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/hexapod/Hexagon.js":
/*!********************************!*\
  !*** ./src/hexapod/Hexagon.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/hexapod/constants.js\");\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector */ \"./src/hexapod/Vector.js\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* * *\n  ..................\n   Hexagon\n  ..................\n\n         |-f-|\n         *---*---*--------   * f - front\n        /    |    \\     |    * s - side\n       /     |     \\    s    * m - middle\n      /      |      \\   |\n     *------cog------* ---\n      \\      |      /|\n       \\     |     / |\n        \\    |    /  |\n         *---*---*   |\n             |       |\n             |---m---|\n\n\n      (leftFront)     (rightFront)\n           v2          v1\n            \\   head  /\n             *---*---*\n            /    |    \\\n  (left    /     |     \\\n  Middle) /      |      \\\n    v3 --*------cog------*-- v0 (rightMiddle)\n          \\      |      /\n           \\     |     /\n            \\    |    /\n             *---*---*\n            /         \\\n          v4           v5\n       (leftBack)   (rightBack)\n\n * * */\n\n\n\nclass Hexagon {\n  constructor(dimensions, flags = {\n    hasNoPoints: false\n  }) {\n    _defineProperty(this, \"dimensions\", void 0);\n\n    _defineProperty(this, \"verticesList\", void 0);\n\n    _defineProperty(this, \"head\", void 0);\n\n    _defineProperty(this, \"cog\", void 0);\n\n    this.dimensions = dimensions;\n\n    if (flags.hasNoPoints) {\n      return;\n    }\n\n    const {\n      front,\n      middle,\n      side\n    } = this.dimensions;\n    const vertexX = [middle, front, -front, -middle, -front, front];\n    const vertexY = [0, side, side, 0, -side, -side];\n    this.verticesList = _constants__WEBPACK_IMPORTED_MODULE_0__[\"POSITION_NAMES_LIST\"].map((position, i) => new _Vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](vertexX[i], vertexY[i], 0, `${position}Vertex`, i));\n    this.head = new _Vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, side, 0, \"headPoint\", 7);\n    this.cog = new _Vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, 0, 0, \"centerOfGravityPoint\", 6);\n  }\n\n  get closedPointsList() {\n    return [...this.verticesList, this.verticesList[0]];\n  }\n\n  get allPointsList() {\n    return [...this.verticesList, this.cog, this.head];\n  }\n\n  cloneTrotShift(transformMatrix, tx, ty, tz) {\n    return this._doTransform(\"cloneTrotShift\", transformMatrix, tx, ty, tz);\n  }\n\n  cloneTrot(transformMatrix) {\n    return this._doTransform(\"cloneTrot\", transformMatrix);\n  }\n\n  cloneShift(tx, ty, tz) {\n    return this._doTransform(\"cloneShift\", tx, ty, tz);\n  }\n\n  _doTransform(transformFunction, ...args) {\n    let clone = new Hexagon(this.dimensions, {\n      hasNoPoints: true\n    });\n    clone.cog = this.cog[transformFunction](...args);\n    clone.head = this.head[transformFunction](...args);\n    clone.verticesList = this.verticesList.map(point => point[transformFunction](...args));\n    return clone;\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Hexagon);\n\n//# sourceURL=webpack://hexapod/./src/hexapod/Hexagon.js?");

/***/ }),

/***/ "./src/hexapod/Linkage.js":
/*!********************************!*\
  !*** ./src/hexapod/Linkage.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometry */ \"./src/hexapod/geometry.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ \"./src/hexapod/constants.js\");\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Vector */ \"./src/hexapod/Vector.js\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* * * * *\n  ..................\n   LINKAGE\n  ..................\n\n     p0 *----* p1\n              \\       * p0 = origin / bodyContactPoint\n               * p2   * p1 = coxiaPoint\n               |      * p2 = femurPoint\n               * p3   * p3 = tibiaPoint / footTipPoint\n                      * coxiaVector = vector from p0 to p1\n     localZ           * femurVector = vector from p1 to p2\n     |  localY        * tibiaVector = vector from p2 to p3\n     | /\n     |/\n     |------ localX   * LegPointId = {legId}-{pointId}\n\n\n             2           1       * legId - legName     - localXaxisAngle\n              \\   head  /        *  0    - rightMiddle - 0\n               *---*---*         *  1    - rightFront  - 45\n              /    |    \\        *  2    - leftFront   - 135\n             /     |     \\       *  3    - leftMiddle  - 180\n         3 -*-----cog-----*- 0   *  4    - leftBack    - 225\n             \\     |     /       *  5    - rightBack   - 315\n              \\    |    /\n               *---*---*          ^ hexapodY\n              /         \\         |\n             4           5        *---> hexapodX\n                                 /\n                                * hexapodZ\n\n                     * localXaxisAngle = angle made by hexapodXaxis and localXaxis\n                     * alpha = angle made by coxia Vector and localXaxis\n             p2      * beta = angle made by coxiaVector and femurVector\n             *              = angle made by points p2, p1 and pxPrime\n            / \\\n       *---*---\\---> pxPrime\n      p0   p1   * p3\n\n\n      p0   p1         * gamma = angle made by vector perpendicular to\n       *---*                    coxiaVector and tibiaVector\n           | \\                = angle made by points pzPrime, p1, p3\n           |  \\\n           V   * p3\n          pzPrime\n\n  ..................\n   LINKAGE PROPERTIES\n  ..................\n\n  {} this.dimensions: { coxia, femur, tibia }\n  {} this.pose: { alpha, beta, gamma }\n  \"\" this.position: \"rightMiddle\" from POSITION_NAMES_LIST or \"linkage-position-not-defined\"\n\n  [] this.allPointsList: A list pointing to each of the four points in the map\n      which the first element being the bodyContactPoint, the last element being the footTipPoint\n\n      [\n          {x, y, z, id: \"5-0\", name: \"rightBack-bodyContactPoint\"},\n          {x, y, z, id: \"5-1\", name: \"rightBack-coxiaPoint\"},\n          {x, y, z, id: \"5-2\", name: \"rightBack-femurPoint\"},\n          {x, y, z, id: \"5-3\", name: \"rightBack-footTipPoint\"},\n      ]\n      each id is prefixed with 5 because the leg point id corresponding to \"rightBack\"\n      position is 5.\n\n  ....................\n  (linkage derived properties)\n  ....................\n\n  {} this.maybeGroundContactPoint: The point which probably is the one in contact\n      with the ground, but not necessarily the case (no guarantees)\n  \"\" this.name: \"{position}Leg\" e.g. \"rightMiddleLeg\"\n  \"\" this.id : a number from 0 to 5 corresponding to a particular position\n\n  * * * * */\n\n\n\n\nclass Linkage {\n  constructor(dimensions, position, originPoint = {\n    x: 0,\n    y: 0,\n    z: 0\n  }, pose = {\n    alpha: 0,\n    beta: 0,\n    gamma: 0\n  }, flags = {\n    hasNoPoints: false\n  }) {\n    _defineProperty(this, \"_buildNameId\", (pointName, id) => ({\n      name: `${this.position}-${pointName}`,\n      id: `${this.id}-${id}`\n    }));\n\n    _defineProperty(this, \"_buildPointNameIds\", () => _constants__WEBPACK_IMPORTED_MODULE_1__[\"LEG_POINT_TYPES_LIST\"].map((pointType, index) => this._buildNameId(pointType, index)));\n\n    Object.assign(this, {\n      dimensions,\n      pose,\n      position\n    });\n\n    if (flags.hasNoPoints) {\n      return;\n    }\n\n    this.allPointsList = this._computePoints(pose, originPoint);\n  }\n\n  get bodyContactPoint() {\n    return this.allPointsList[0];\n  }\n\n  get coxiaPoint() {\n    return this.allPointsList[1];\n  }\n\n  get femurPoint() {\n    return this.allPointsList[2];\n  }\n\n  get footTipPoint() {\n    return this.allPointsList[3];\n  }\n\n  get id() {\n    return _constants__WEBPACK_IMPORTED_MODULE_1__[\"POSITION_NAME_TO_ID_MAP\"][this.position];\n  }\n\n  get name() {\n    return `${this.position}Leg`;\n  }\n\n  get maybeGroundContactPoint() {\n    const reversedList = this.allPointsList.slice().reverse();\n    const testPoint = reversedList[0];\n    const maybeGroundContactPoint = reversedList.reduce((testPoint, point) => point.z < testPoint.z ? point : testPoint, testPoint);\n    return maybeGroundContactPoint;\n  }\n  /* *\n   * .............\n   * clone (translate) rotate shift cloneTrotShift\n   * .............\n   *\n   * params type:\n   *   matrix:  4x4 matrix\n   *   tx, ty, tz: numbers\n   *\n   * Return a copy of the leg with the same properties\n   * except all the points are rotated and shifted\n   * given the transformation matrix (4x4 matrix) and tx, ty, tz\n   * Note: The transformation matrix can translate the leg\n   * if the last column of of the matrix have non-zero elements\n   * and again be translated by tx, ty, tz\n   * */\n\n\n  cloneTrotShift(transformMatrix, tx, ty, tz) {\n    return this._doTransform(\"cloneTrotShift\", transformMatrix, tx, ty, tz);\n  }\n\n  cloneTrot(transformMatrix) {\n    return this._doTransform(\"cloneTrot\", transformMatrix);\n  }\n\n  cloneShift(tx, ty, tz) {\n    return this._doTransform(\"cloneShift\", tx, ty, tz);\n  }\n\n  _doTransform(transformFunction, ...args) {\n    const newPointsList = this.allPointsList.map(oldPoint => oldPoint[transformFunction](...args));\n    return this._buildClone(newPointsList);\n  }\n\n  _buildClone(allPointsList) {\n    let clone = new Linkage(this.dimensions, this.position, this.bodyContactPoint, this.pose, {\n      hasNoPoints: true\n    }); // override allPointsList of clone\n\n    clone.allPointsList = allPointsList;\n    return clone;\n  }\n  /* *\n   * .............\n   * structure of pointNameIds\n   * .............\n   *\n   * pointNameIds = [\n   *   { name: \"{legPosition}-bodyContactPoint\", id: \"{legId}-0\" },\n   *   { name: \"{legPosition}-coxiaPoint\", id: \"{legId}-1\" },\n   *   { name: \"{legPosition}-femurPoint\", id: \"{legId}-2\" },\n   *   { name: \"{legPosition}-footTipPoint\", id: \"{legId}-3\" },\n   * ]\n   *\n   * */\n\n\n  /* *\n   * ................\n   * STEP 1 of computing points:\n   *   find points wrt body contact point\n   * ................\n   * NOTE:\n   * matrix_ab is the matrix which defines the\n   * pose of that coordinate system defined by\n   * matrix_b wrt the coordinate system defined by matrix_a\n   * matrix_ab is the pose of matrix_b wrt matrix_a\n   * where pa is the origin of matrix_a\n   * and pb is the origin of matrix_b wrt pa\n   *\n   * */\n  _computePointsWrtBodyContact(beta, gamma) {\n    const matrix01 = Object(_geometry__WEBPACK_IMPORTED_MODULE_0__[\"tRotYmatrix\"])(-beta, this.dimensions.coxia, 0, 0);\n    const matrix12 = Object(_geometry__WEBPACK_IMPORTED_MODULE_0__[\"tRotYmatrix\"])(90 - gamma, this.dimensions.femur, 0, 0);\n    const matrix23 = Object(_geometry__WEBPACK_IMPORTED_MODULE_0__[\"tRotYmatrix\"])(0, this.dimensions.tibia, 0, 0);\n    const matrix02 = Object(_geometry__WEBPACK_IMPORTED_MODULE_0__[\"multiply4x4\"])(matrix01, matrix12);\n    const matrix03 = Object(_geometry__WEBPACK_IMPORTED_MODULE_0__[\"multiply4x4\"])(matrix02, matrix23);\n    const originPoint = new _Vector__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 0);\n    const localPoints = [originPoint, // bodyContactPoint\n    originPoint.cloneTrot(matrix01), // coxiaPoint\n    originPoint.cloneTrot(matrix02), // femurPoint\n    originPoint.cloneTrot(matrix03) // footTipPoint\n    ];\n    return localPoints;\n  }\n  /* *\n   * ................\n   * STEP 2 of computing points:\n   *   find local points wrt hexapod's center of gravity (0, 0, 0)\n   * ................\n   * */\n\n\n  _computePointsWrtHexapodCog(alpha, originPoint, localPoints, pointNameIds) {\n    const zAngle = _constants__WEBPACK_IMPORTED_MODULE_1__[\"POSITION_NAME_TO_AXIS_ANGLE_MAP\"][this.position] + alpha;\n    const twistMatrix = Object(_geometry__WEBPACK_IMPORTED_MODULE_0__[\"tRotZmatrix\"])(zAngle, originPoint.x, originPoint.y, originPoint.z);\n    const allPointsList = localPoints.map((localPoint, index) => {\n      const name = pointNameIds[index].name;\n      const id = pointNameIds[index].id;\n      const point = localPoint.newTrot(twistMatrix, name, id);\n      return point;\n    });\n    return allPointsList;\n  }\n  /* *\n   *  Example of allPointsList =  [\n   *     {x, y, z, id: \"5-0\", name: \"rightBack-bodyContactPoint\"},\n   *     {x, y, z, id: \"5-1\", name: \"rightBack-coxiaPoint\"},\n   *     {x, y, z, id: \"5-2\", name: \"rightBack-femurPoint\"},\n   *     {x, y, z, id: \"5-3\", name: \"rightBack-footTipPoint\"},\n   * ]\n   * x, y, z are numbers\n   * */\n\n\n  _computePoints(pose, originPoint) {\n    const {\n      alpha,\n      beta,\n      gamma\n    } = pose;\n\n    const pointNameIds = this._buildPointNameIds();\n\n    const localPoints = this._computePointsWrtBodyContact(beta, gamma); // prettier-ignore\n\n\n    const allPointsList = this._computePointsWrtHexapodCog(alpha, originPoint, localPoints, pointNameIds);\n\n    return allPointsList;\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Linkage);\n\n//# sourceURL=webpack://hexapod/./src/hexapod/Linkage.js?");

/***/ }),

/***/ "./src/hexapod/Vector.js":
/*!*******************************!*\
  !*** ./src/hexapod/Vector.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass Vector {\n  constructor(x, y, z, name = \"no-name-point\", id = \"no-id-point\") {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.name = name;\n    this.id = id;\n  }\n\n  newTrot(transformMatrix, name = \"unnamed-point\", id = \"no-id\") {\n    // given point `point` location wrt a local axes\n    // coordinate frame\n    // find point in a global axes coordinate frame\n    // where the local axes wrt the global frame is defined by\n    // parameter transformMatrix\n    const [r0, r1, r2] = transformMatrix.slice(0, 3);\n    const [r00, r01, r02, tx] = r0;\n    const [r10, r11, r12, ty] = r1;\n    const [r20, r21, r22, tz] = r2;\n    const newX = this.x * r00 + this.y * r01 + this.z * r02 + tx;\n    const newY = this.x * r10 + this.y * r11 + this.z * r12 + ty;\n    const newZ = this.x * r20 + this.y * r21 + this.z * r22 + tz;\n    return new Vector(newX, newY, newZ, name, id);\n  }\n\n  cloneTrot(transformMatrix) {\n    return this.newTrot(transformMatrix, this.name, this.id);\n  }\n\n  cloneShift(tx, ty, tz) {\n    return new Vector(this.x + tx, this.y + ty, this.z + tz, this.name, this.id);\n  }\n\n  cloneTrotShift(transformMatrix, tx, ty, tz) {\n    return this.cloneTrot(transformMatrix).cloneShift(tx, ty, tz);\n  }\n\n  toMarkdownString() {\n    const x = this.x.toFixed(2);\n    const y = this.y.toFixed(2);\n    const z = this.z.toFixed(2);\n    const markdownString = `${this.name}\\n\\n(x: ${x}, y: ${y}, z: ${z})`;\n    return markdownString;\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Vector);\n\n//# sourceURL=webpack://hexapod/./src/hexapod/Vector.js?");

/***/ }),

/***/ "./src/hexapod/VirtualHexapod.js":
/*!***************************************!*\
  !*** ./src/hexapod/VirtualHexapod.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/hexapod/constants.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geometry */ \"./src/hexapod/geometry.js\");\n/* harmony import */ var _templates__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../templates */ \"./src/templates/index.js\");\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Vector */ \"./src/hexapod/Vector.js\");\n/* harmony import */ var _Hexagon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Hexagon */ \"./src/hexapod/Hexagon.js\");\n/* harmony import */ var _Linkage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Linkage */ \"./src/hexapod/Linkage.js\");\n/* harmony import */ var _solvers_orient_orientSolverGeneral__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./solvers/orient/orientSolverGeneral */ \"./src/hexapod/solvers/orient/orientSolverGeneral.js\");\n/* harmony import */ var _solvers_orient_orientSolverSpecific__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./solvers/orient/orientSolverSpecific */ \"./src/hexapod/solvers/orient/orientSolverSpecific.js\");\n/* harmony import */ var _solvers_twistSolver__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./solvers/twistSolver */ \"./src/hexapod/solvers/twistSolver.js\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\n\n\n\n\nfunction setLegAngles() {}\n\nconst DEFAULT_LOCAL_AXES = {\n  xAxis: new _Vector__WEBPACK_IMPORTED_MODULE_3__[\"default\"](1, 0, 0, \"hexapodXaxis\"),\n  yAxis: new _Vector__WEBPACK_IMPORTED_MODULE_3__[\"default\"](0, 1, 0, \"hexapodYaxis\"),\n  zAxis: new _Vector__WEBPACK_IMPORTED_MODULE_3__[\"default\"](0, 0, 1, \"hexapodZaxis\")\n};\n\nconst transformLocalAxes = (localAxes, twistMatrix) => ({\n  xAxis: localAxes.xAxis.cloneTrot(twistMatrix),\n  yAxis: localAxes.yAxis.cloneTrot(twistMatrix),\n  zAxis: localAxes.zAxis.cloneTrot(twistMatrix)\n});\n/* * *\n build a list of six legs\n given dimensions and  the respective\n bodyContacts points and pose\n * * */\n\n\nconst buildLegsList = (bodyContactPoints, pose, legDimensions) => _constants__WEBPACK_IMPORTED_MODULE_0__[\"POSITION_NAMES_LIST\"].map((position, index) => new _Linkage__WEBPACK_IMPORTED_MODULE_5__[\"default\"](legDimensions, position, bodyContactPoints[index], pose[position]));\n\nconst hexapodErrorInfo = () => ({\n  isAlert: true,\n  subject: \"Unstable position.\",\n  body: \"error in solving for orientation \"\n});\n\nconst hexapodSuccessInfo = () => ({\n  isAlert: false,\n  subject: \"Success!\",\n  body: \"Stable orientation found.\"\n});\n/* * *\n\n............................\n Virtual Hexapod properties\n............................\n\nProperty types:\n{}: hash map / object / dictionary\n[]: array / list\n##: number\n\"\": string\n\n{} this.dimensions: {front, side, middle, coxia, femur, tibia}\n\n{} this.pose: A hash mapping the position name to a hash map of three angles\n    which define the pose of the hexapod\n    i.e. { rightMiddle: {alpha, beta, gamma },\n           leftBack: { alpha, betam gamma },\n             ...\n         }\n\n[] this.body: A hexagon object\n    which contains all the info of the 8 points defining the hexapod body\n    (6 vertices, 1 head, 1 center of gravity)\n\n[] this.legs: A list which has elements that point to six Linkage objects.\n    The order goes counter clockwise starting from the first element\n    which is the rightMiddle leg up until the last element which is rightBack leg.\n    Each leg contains the points that define that leg\n    as well as other properties pertaining it (see Linkage class)\n\n[] this.legPositionsOnGround: A list of the leg positions (strings)\n    that are known to be in contact with the ground\n\n{} this.localAxes: A hash containing three vectors defining the local\n    coordinate frame of the hexapod wrt the world coordinate frame\n    i.e. {\n        xAxis: {x, y, z, name=\"hexapodXaxis\", id=\"no-id\"},\n        yAxis: {x, y, z, name=\"hexapodYaxis\", id=\"no-id\"},\n        zAxis: {x, y, z, name=\"hexapodZaxis\", id=\"no-id\"},\n    }\n\n....................\n(virtual hexapod derived properties)\n....................\n\n{} this.bodyDimensions: { front, side, middle }\n{} this.legDimensions: { coxia, femur, tibia }\n\n## this.distanceFromGround: A number which is the perpendicular distance\n    from the hexapod's center of gravity to the ground plane\n\n{} this.cogProjection: a point that represents the projection\n    of the hexapod's center of gravity point to the ground plane\n    i.e { x, y, z, name=\"centerOfGravityProjectionPoint\", id=\"no-id\"}\n\n[] this.groundContactPoints: a list whose elements point to points\n    from the leg which contacts the ground.\n    This list can contain 6 or less elements.\n    (It can have a length of 3, 4, 5 or 6)\n    i.e. [\n        { x, y, z, name=\"rightMiddle-femurPoint\", id=\"0-2\"},\n        { x, y, z, name=\"leftBack-footTipPoint\", id=4-3},\n         ...\n    ]\n\n * * */\n\n\nclass VirtualHexapod {\n  constructor(dimensions, pose, flags = {\n    hasNoPoints: false,\n    assumeKnownGroundPoints: false,\n    wontRotate: false\n  }) {\n    _defineProperty(this, \"dimensions\", void 0);\n\n    _defineProperty(this, \"pose\", void 0);\n\n    _defineProperty(this, \"body\", void 0);\n\n    _defineProperty(this, \"legs\", void 0);\n\n    _defineProperty(this, \"legPositionsOnGround\", void 0);\n\n    _defineProperty(this, \"localAxes\", void 0);\n\n    _defineProperty(this, \"foundSolution\", void 0);\n\n    Object.assign(this, {\n      dimensions,\n      pose\n    });\n\n    if (flags.hasNoPoints) {\n      return;\n    } // .................\n    // STEP 1: Build a flatHexagon and 'dangling' linkages\n    // then find  properties we can derive from this\n    // .................\n\n\n    const flatHexagon = new _Hexagon__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.bodyDimensions); // legsNoGravity are linkages have the correct pose but\n    // are not necessarily correctly oriented wrt the world\n    // prettier-ignore\n\n    const legsNoGravity = buildLegsList(flatHexagon.verticesList, this.pose, this.legDimensions); // console.log(this.legDimensions)\n    // `solved` has:\n    // - new orientation of the body (nAxis)\n    // - which legs are on the ground (groundLegsNoGravity)\n    // - distance of center of gravity to the ground (height)\n\n    const solved = flags.assumeKnownGroundPoints ? _solvers_orient_orientSolverSpecific__WEBPACK_IMPORTED_MODULE_7__[\"computeOrientationProperties\"](legsNoGravity) : _solvers_orient_orientSolverGeneral__WEBPACK_IMPORTED_MODULE_6__[\"computeOrientationProperties\"](legsNoGravity);\n\n    if (solved === null) {\n      this.foundSolution = false;\n      return;\n    }\n\n    this.foundSolution = true;\n    this.legPositionsOnGround = solved.groundLegsNoGravity.map(leg => leg.position); // .................\n    // STEP 2: Rotate and shift legs and body given what we've solved\n    // .................\n    // prettier-ignore\n\n    const transformMatrix = Object(_geometry__WEBPACK_IMPORTED_MODULE_1__[\"matrixToAlignVectorAtoB\"])(solved.nAxis, DEFAULT_LOCAL_AXES.zAxis);\n    this.legs = legsNoGravity.map(leg => leg.cloneTrotShift(transformMatrix, 0, 0, solved.height));\n    this.body = flatHexagon.cloneTrotShift(transformMatrix, 0, 0, solved.height);\n    this.localAxes = transformLocalAxes(DEFAULT_LOCAL_AXES, transformMatrix); // .................\n    // STEP 3: Twist around the zAxis if you have to\n    // .................\n\n    if (flags.wontRotate) {\n      return;\n    } // case 1: hexapod will not twist about z axis\n\n\n    if (this.legs.every(leg => leg.pose.alpha === 0)) {\n      return;\n    } // case 2: When all alpha angles are the same for all legs\n\n\n    const twistAngle = Object(_solvers_twistSolver__WEBPACK_IMPORTED_MODULE_8__[\"simpleTwist\"])(solved.groundLegsNoGravity);\n\n    if (this.maybeTwistAngle !== 0) {\n      // console.log(twistAngle)\n      this._twist(twistAngle);\n\n      return;\n    } // case 3: All other cases\n\n\n    if (Object(_solvers_twistSolver__WEBPACK_IMPORTED_MODULE_8__[\"mightTwist\"])(solved.groundLegsNoGravity)) {\n      this._handleComplexTwist(flatHexagon.verticesList);\n    }\n  }\n\n  get distanceFromGround() {\n    return this.body.cog.z;\n  }\n\n  get cogProjection() {\n    return new _Vector__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.body.cog.x, this.body.cog.y, 0, \"centerOfGravityProjectionPoint\");\n  }\n\n  get info() {\n    return this.foundSolution ? hexapodSuccessInfo() : hexapodErrorInfo();\n  }\n\n  get bodyDimensions() {\n    const {\n      front,\n      middle,\n      side\n    } = this.dimensions;\n    return {\n      front,\n      middle,\n      side\n    };\n  }\n\n  get legDimensions() {\n    const {\n      coxia,\n      femur,\n      tibia\n    } = this.dimensions;\n    return {\n      coxia,\n      femur,\n      tibia\n    };\n  }\n\n  get groundContactPoints() {\n    return this.legPositionsOnGround.map(position => {\n      const index = _constants__WEBPACK_IMPORTED_MODULE_0__[\"POSITION_NAME_TO_ID_MAP\"][position];\n      return this.legs[index].maybeGroundContactPoint;\n    });\n  }\n\n  cloneTrot(transformMatrix) {\n    // Note: transform matrix passed should be purely rotational\n    const body = this.body.cloneTrot(transformMatrix);\n    const legs = this.legs.map(leg => leg.cloneTrot(transformMatrix));\n    const localAxes = transformLocalAxes(this.localAxes, transformMatrix);\n    return this._buildClone(body, legs, localAxes);\n  }\n\n  cloneShift(tx, ty, tz) {\n    const body = this.body.cloneShift(tx, ty, tz);\n    const legs = this.legs.map(leg => leg.cloneShift(tx, ty, tz));\n    return this._buildClone(body, legs, this.localAxes);\n  }\n\n  _buildClone(body, legs, localAxes) {\n    // FIXME:\n    // After shifting and/or rotating the hexapod\n    // We can no longer guarrantee that the legPositionsOnGround\n    // is the same as before\n    // must handle this soon!!\n    let clone = new VirtualHexapod(this.dimensions, this.pose, {\n      hasNoPoints: true\n    });\n    Object.assign(clone, {\n      body,\n      legs,\n      localAxes,\n      legPositionsOnGround: this.legPositionsOnGround,\n      foundSolution: this.foundSolution\n    }); // pub msg here\n    // console.log(legs)\n    // setLegAngles(legs)\n\n    return clone;\n  }\n\n  _handleComplexTwist(verticesList) {\n    // console.log(verticesList)\n    // prettier-ignore\n    const defaultLegs = buildLegsList(verticesList, _templates__WEBPACK_IMPORTED_MODULE_2__[\"DEFAULT_POSE\"], this.legDimensions); // DefaultLegs: The list of legs when a hexapod\n    // of these dimensions is at the default pose\n    // (ie all angles are zero)\n    // DefaultPoints: the corresponding ground contact\n    // points of defaultLegs\n\n    const defaultPoints = defaultLegs.map(leg => leg.cloneShift(0, 0, this.dimensions.tibia).maybeGroundContactPoint); // currentPoints: Where the ground contact points are currently\n    // given all the transformations we have done so far\n\n    const currentPoints = this.groundContactPoints;\n    const twistAngle = Object(_solvers_twistSolver__WEBPACK_IMPORTED_MODULE_8__[\"complexTwist\"])(currentPoints, defaultPoints);\n\n    if (twistAngle !== 0) {\n      this._twist();\n    }\n  }\n\n  _twist(twistAngle) {\n    const twistMatrix = Object(_geometry__WEBPACK_IMPORTED_MODULE_1__[\"tRotZmatrix\"])(twistAngle);\n    this.body = this.body.cloneTrot(twistMatrix);\n    this.legs = this.legs.map(leg => leg.cloneTrot(twistMatrix));\n    this.localAxes = transformLocalAxes(this.localAxes, twistMatrix); // pub msg here\n    // console.log(this.legs)\n    // setLegAngles(this.legs)\n  }\n\n  _danglingHexapod(body, legs) {\n    this.body = body;\n    this.legs = legs;\n    this.localAxes = DEFAULT_LOCAL_AXES;\n    this.legPositionsOnGround = [];\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (VirtualHexapod);\n\n//# sourceURL=webpack://hexapod/./src/hexapod/VirtualHexapod.js?");

/***/ }),

/***/ "./src/hexapod/constants.js":
/*!**********************************!*\
  !*** ./src/hexapod/constants.js ***!
  \**********************************/
/*! exports provided: ANGLE_NAMES_LIST, LEG_POINT_TYPES_LIST, POSITION_NAME_TO_ID_MAP, POSITION_NAME_TO_AXIS_ANGLE_MAP, POSITION_NAMES_LIST, NUMBER_OF_LEGS, POSITION_NAME_TO_IS_LEFT_MAP, MAX_ANGLES */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ANGLE_NAMES_LIST\", function() { return ANGLE_NAMES_LIST; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LEG_POINT_TYPES_LIST\", function() { return LEG_POINT_TYPES_LIST; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"POSITION_NAME_TO_ID_MAP\", function() { return POSITION_NAME_TO_ID_MAP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"POSITION_NAME_TO_AXIS_ANGLE_MAP\", function() { return POSITION_NAME_TO_AXIS_ANGLE_MAP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"POSITION_NAMES_LIST\", function() { return POSITION_NAMES_LIST; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NUMBER_OF_LEGS\", function() { return NUMBER_OF_LEGS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"POSITION_NAME_TO_IS_LEFT_MAP\", function() { return POSITION_NAME_TO_IS_LEFT_MAP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MAX_ANGLES\", function() { return MAX_ANGLES; });\nconst LEG_POINT_TYPES_LIST = [\"bodyContactPoint\", \"coxiaPoint\", \"femurPoint\", \"footTipPoint\"];\nconst POSITION_NAME_TO_ID_MAP = {\n  rightMiddle: 0,\n  rightFront: 1,\n  leftFront: 2,\n  leftMiddle: 3,\n  leftBack: 4,\n  rightBack: 5\n};\nconst POSITION_NAMES_LIST = [\"rightMiddle\", \"rightFront\", \"leftFront\", \"leftMiddle\", \"leftBack\", \"rightBack\"];\nconst ANGLE_NAMES_LIST = [\"alpha\", \"beta\", \"gamma\"];\nconst MAX_ANGLES = {\n  alpha: 90,\n  beta: 180,\n  gamma: 180\n};\n/*\n\n   hexapodYaxis\n       ^\n       |\n       |\n       *-----> hexapodXaxis\n      / (cog)\n     /\n  hexapodZaxis\n\n  Relative x-axis, for each attached linkage\n\n  (+135)  x2          x1 (+45)\n           \\   head  /\n            *---*---*\n           /    |    \\\n          /     |     \\\n (+180)  /      |      \\\n   x3 --*------cog------*-- x0 (+0)\n         \\      |      /\n          \\     |     /\n           \\    |    /\n            *---*---*\n           /         \\\n         x4           x5\n      (+225)        (+315)\n */\n\nconst POSITION_NAME_TO_AXIS_ANGLE_MAP = {\n  rightMiddle: 0,\n  rightFront: 45,\n  leftFront: 135,\n  leftMiddle: 180,\n  leftBack: 225,\n  rightBack: 315\n};\nconst POSITION_NAME_TO_IS_LEFT_MAP = {\n  rightMiddle: false,\n  rightFront: false,\n  leftFront: true,\n  leftMiddle: true,\n  leftBack: true,\n  rightBack: false\n};\nconst NUMBER_OF_LEGS = 6;\n\n\n//# sourceURL=webpack://hexapod/./src/hexapod/constants.js?");

/***/ }),

/***/ "./src/hexapod/geometry.js":
/*!*********************************!*\
  !*** ./src/hexapod/geometry.js ***!
  \*********************************/
/*! exports provided: degrees, radians, isTriangle, dot, cross, getNormalofThreePoints, scaleVector, vectorFromTo, addVectors, getUnitVector, projectedVectorOntoPlane, vectorLength, angleBetween, angleOppositeOfLastSide, isCounterClockwise, tRotXmatrix, tRotYmatrix, tRotZmatrix, tRotXYZmatrix, skew, matrixToAlignVectorAtoB, multiply4x4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"degrees\", function() { return degrees; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"radians\", function() { return radians; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isTriangle\", function() { return isTriangle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dot\", function() { return dot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cross\", function() { return cross; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getNormalofThreePoints\", function() { return getNormalofThreePoints; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleVector\", function() { return scaleVector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"vectorFromTo\", function() { return vectorFromTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addVectors\", function() { return addVectors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getUnitVector\", function() { return getUnitVector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"projectedVectorOntoPlane\", function() { return projectedVectorOntoPlane; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"vectorLength\", function() { return vectorLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"angleBetween\", function() { return angleBetween; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"angleOppositeOfLastSide\", function() { return angleOppositeOfLastSide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isCounterClockwise\", function() { return isCounterClockwise; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tRotXmatrix\", function() { return tRotXmatrix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tRotYmatrix\", function() { return tRotYmatrix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tRotZmatrix\", function() { return tRotZmatrix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tRotXYZmatrix\", function() { return tRotXYZmatrix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"skew\", function() { return skew; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"matrixToAlignVectorAtoB\", function() { return matrixToAlignVectorAtoB; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply4x4\", function() { return multiply4x4; });\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector */ \"./src/hexapod/Vector.js\");\n\n\nconst degrees = thetaRadians => thetaRadians * 180 / Math.PI;\n\nconst radians = thetaDegrees => thetaDegrees * Math.PI / 180;\n\nconst isTriangle = (a, b, c) => a + b > c && a + c > b && b + c > a;\n\nconst dot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;\n\nconst vectorLength = v => Math.sqrt(dot(v, v));\n\nconst isCounterClockwise = (a, b, n) => dot(a, cross(b, n)) > 0;\n\nconst vectorFromTo = (a, b) => new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](b.x - a.x, b.y - a.y, b.z - a.z);\n\nconst scaleVector = (v, d) => new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](d * v.x, d * v.y, d * v.z);\n\nconst addVectors = (a, b) => new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](a.x + b.x, a.y + b.y, a.z + b.z);\n\nconst getUnitVector = v => scaleVector(v, 1 / vectorLength(v));\n\nconst cross = (a, b) => {\n  const x = a.y * b.z - a.z * b.y;\n  const y = a.z * b.x - a.x * b.z;\n  const z = a.x * b.y - a.y * b.x;\n  return new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](x, y, z);\n};\n\nconst getNormalofThreePoints = (a, b, c) => {\n  const ab = vectorFromTo(a, b);\n  const ac = vectorFromTo(a, c);\n  const n = cross(ab, ac);\n  const len_n = vectorLength(n);\n  const unit_n = scaleVector(n, 1 / len_n);\n  return unit_n;\n};\n\nconst acosDegrees = ratio => {\n  const thetaRadians = Math.acos(ratio); // mimicks behavior of python numpy acos\n\n  if (isNaN(thetaRadians)) {\n    return 0;\n  }\n\n  return degrees(thetaRadians);\n};\n\nconst angleOppositeOfLastSide = (a, b, c) => {\n  if (a === 0 || b === 0) {\n    return null;\n  }\n\n  const cosTheta = (a * a + b * b - c * c) / (2 * a * b);\n  return acosDegrees(cosTheta);\n};\n\nconst angleBetween = (a, b) => {\n  if (vectorLength(a) === 0 || vectorLength(b) === 0) {\n    return 0;\n  }\n\n  const cosTheta = dot(a, b) / Math.sqrt(dot(a, a) * dot(b, b));\n  return acosDegrees(cosTheta);\n}; // u is the vector, n is the plane normal\n\n\nconst projectedVectorOntoPlane = (u, n) => {\n  const s = dot(u, n) / dot(n, n);\n  const tempVector = scaleVector(n, s);\n  return vectorFromTo(tempVector, u);\n};\n\nconst getSinCos = theta => [Math.sin(radians(theta)), Math.cos(radians(theta))];\n\nconst IDENTITY_MATRIX_4x4 = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];\n\nconst uniformMatrix4x4 = d => {\n  const dRow = [d, d, d, d];\n  return [dRow.slice(), dRow.slice(), dRow.slice(), dRow.slice()];\n};\n\nconst add = (a, b) => a + b;\n\nconst multiply = (a, b) => a * b;\n\nconst operate4x4 = (matrixA, matrixB, operation) => {\n  let resultMatrix = uniformMatrix4x4(null);\n\n  for (let i = 0; i < 4; i++) {\n    for (let j = 0; j < 4; j++) {\n      resultMatrix[i][j] = operation.call(null, matrixA[i][j], matrixB[i][j]);\n    }\n  }\n\n  return resultMatrix;\n};\n\nconst dotMultiply4x4 = (matrixA, matrixB) => {\n  return operate4x4(matrixA, matrixB, multiply);\n};\n\nconst add4x4 = (matrixA, matrixB) => {\n  return operate4x4(matrixA, matrixB, add);\n};\n\nconst multiply4x4 = (matrixA, matrixB) => {\n  let resultMatrix = uniformMatrix4x4(null);\n\n  for (let i = 0; i < 4; i++) {\n    for (let j = 0; j < 4; j++) {\n      resultMatrix[i][j] = matrixA[i][0] * matrixB[0][j] + matrixA[i][1] * matrixB[1][j] + matrixA[i][2] * matrixB[2][j] + matrixA[i][3] * matrixB[3][j];\n    }\n  }\n\n  return resultMatrix;\n};\n\nfunction tRotXmatrix(theta, tx = 0, ty = 0, tz = 0) {\n  const [s, c] = getSinCos(theta);\n  return [[1, 0, 0, tx], [0, c, -s, ty], [0, s, c, tz], [0, 0, 0, 1]];\n}\n\nfunction tRotYmatrix(theta, tx = 0, ty = 0, tz = 0) {\n  const [s, c] = getSinCos(theta);\n  return [[c, 0, s, tx], [0, 1, 0, ty], [-s, 0, c, tz], [0, 0, 0, 1]];\n}\n\nfunction tRotZmatrix(theta, tx = 0, ty = 0, tz = 0) {\n  const [s, c] = getSinCos(theta);\n  return [[c, -s, 0, tx], [s, c, 0, ty], [0, 0, 1, tz], [0, 0, 0, 1]];\n}\n\nconst tRotXYZmatrix = (xTheta, yTheta, zTheta) => {\n  const rx = tRotXmatrix(xTheta);\n  const ry = tRotYmatrix(yTheta);\n  const rz = tRotZmatrix(zTheta);\n  const rxy = multiply4x4(rx, ry);\n  const rxyz = multiply4x4(rxy, rz);\n  return rxyz;\n};\n\nconst skew = p => [[0, -p.z, p.y, 0], [p.z, 0, -p.x, 0], [-p.y, p.x, 0, 0], [0, 0, 0, 1]];\n\nconst matrixToAlignVectorAtoB = (a, b) => {\n  const v = cross(a, b);\n  const s = vectorLength(v); // When angle between a and b is zero or 180 degrees\n  // cross product is 0, R = I\n\n  if (s === 0) {\n    return IDENTITY_MATRIX_4x4;\n  }\n\n  const c = dot(a, b);\n  const vx = skew(v);\n  const d = (1 - c) / (s * s);\n  const vx2 = multiply4x4(vx, vx);\n  const dMatrix = uniformMatrix4x4(d);\n  const dvx2 = dotMultiply4x4(vx2, dMatrix);\n  const temp = add4x4(IDENTITY_MATRIX_4x4, vx);\n  const transformMatrix = add4x4(temp, dvx2);\n  return transformMatrix;\n};\n\n\n\n//# sourceURL=webpack://hexapod/./src/hexapod/geometry.js?");

/***/ }),

/***/ "./src/hexapod/index.js":
/*!******************************!*\
  !*** ./src/hexapod/index.js ***!
  \******************************/
/*! exports provided: VirtualHexapod, getNewPlotParams, solveInverseKinematics, POSITION_NAMES_LIST */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VirtualHexapod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VirtualHexapod */ \"./src/hexapod/VirtualHexapod.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VirtualHexapod\", function() { return _VirtualHexapod__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _solvers_ik_hexapodSolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./solvers/ik/hexapodSolver */ \"./src/hexapod/solvers/ik/hexapodSolver.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"solveInverseKinematics\", function() { return _solvers_ik_hexapodSolver__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _templates_plotter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../templates/plotter */ \"./src/templates/plotter.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getNewPlotParams\", function() { return _templates_plotter__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants */ \"./src/hexapod/constants.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"POSITION_NAMES_LIST\", function() { return _constants__WEBPACK_IMPORTED_MODULE_3__[\"POSITION_NAMES_LIST\"]; });\n\n\n\n\n\n\n\n//# sourceURL=webpack://hexapod/./src/hexapod/index.js?");

/***/ }),

/***/ "./src/hexapod/solvers/ik/HexapodSupportCheck.js":
/*!*******************************************************!*\
  !*** ./src/hexapod/solvers/ik/HexapodSupportCheck.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants */ \"./src/hexapod/constants.js\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nclass HexapodSupportCheck {}\n\n_defineProperty(HexapodSupportCheck, \"reason\", {\n  MIGHT_BE_STABLE_LESS: \"Might be stable.\\nLess than three known legs are off the ground.\",\n  TOO_MANY_LEGS_OFF: \"Definitely Unstable.\\nToo many legs off the floor.\",\n  RIGHT_LEGS_OFF: \"Definitely Unstable.\\nAll right legs are off the floor.\",\n  LEFT_LEGS_OFF: \"Definitely Unstable.\\nAll left legs are off the floor.\",\n  MIGHT_BE_STABLE_MORE: \"Might be stable.\\nThree known legs are off the ground.\\nOne is on opposite side of the other two.\"\n});\n\n_defineProperty(HexapodSupportCheck, \"checkSupport\", legsNamesoffGround => {\n  const reason = HexapodSupportCheck.reason;\n\n  if (legsNamesoffGround.length < 3) {\n    return [false, reason.MIGHT_BE_STABLE_LESS];\n  }\n\n  if (legsNamesoffGround.length >= 4) {\n    return [true, reason.TOO_MANY_LEGS_OFF];\n  } // Leg count is exactly 3 at this point\n\n\n  const legLeftOrRight = legsNamesoffGround.map(legPosition => _constants__WEBPACK_IMPORTED_MODULE_0__[\"POSITION_NAME_TO_IS_LEFT_MAP\"][legPosition]);\n\n  if (legLeftOrRight.every(isLeft => !isLeft)) {\n    return [true, reason.RIGHT_LEGS_OFF];\n  }\n\n  if (legLeftOrRight.every(isLeft => isLeft)) {\n    return [true, reason.LEFT_LEGS_OFF];\n  }\n\n  return [false, reason.MIGHT_BE_STABLE_MORE];\n});\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (HexapodSupportCheck);\n\n//# sourceURL=webpack://hexapod/./src/hexapod/solvers/ik/HexapodSupportCheck.js?");

/***/ }),

/***/ "./src/hexapod/solvers/ik/IKInfo.js":
/*!******************************************!*\
  !*** ./src/hexapod/solvers/ik/IKInfo.js ***!
  \******************************************/
/*! exports provided: LegIKInfo, IKMessage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LegIKInfo\", function() { return LegIKInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IKMessage\", function() { return IKMessage; });\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass IKMessage {}\n\n_defineProperty(IKMessage, \"success\", {\n  subject: \"Success.\",\n  body: \"All legs are on the floor.\"\n});\n\n_defineProperty(IKMessage, \"successLegsOnAir\", legs => ({\n  subject: \"Success.\",\n  body: `But some legs won't reach target points on the ground:\\n${IKMessage.bulletPoints(legs)}`\n}));\n\n_defineProperty(IKMessage, \"noSupport\", (reason, legs, flags = {\n  listLegs: false\n}) => ({\n  subject: \"Failure: No Support.\",\n  body: `${reason}\\n${flags.listLegs ? IKMessage.bulletPoints(legs) : \"\"}`\n}));\n\n_defineProperty(IKMessage, \"badPoint\", point => ({\n  subject: \"Failure: Bad Point.\",\n  body: `At least one point would be shoved to the ground:\\n${point.toMarkdownString()}`\n}));\n\n_defineProperty(IKMessage, \"bulletPoints\", elements => elements.reduce((msg, position) => msg + ` - ${position}\\n`, \"\"));\n\n_defineProperty(IKMessage, \"badLeg\", message => ({\n  subject: `Failure: Bad leg.`,\n  body: message\n}));\n\n_defineProperty(IKMessage, \"alphaNotInRange\", (position, alpha, maxAngle) => ({\n  subject: `Failure: Alpha not within range`,\n  body: `The alpha (${alpha}) computed for ${position} leg is not within -${maxAngle} < alpha < ${maxAngle}`\n}));\n\n_defineProperty(IKMessage, \"initialized\", {\n  subject: \"Initialized\",\n  body: \"Has not solved for anything yet.\"\n});\n\nclass LegIKInfo {}\n\n_defineProperty(LegIKInfo, \"targetReached\", position => ({\n  legPosition: position,\n  message: `Success! (${position})`,\n  obtainedSolution: true,\n  reachedTarget: true\n}));\n\n_defineProperty(LegIKInfo, \"targetNotReached\", position => ({\n  legPosition: position,\n  message: `Success! But this leg won't reach the target ground point. (${position})`,\n  obtainedSolution: true,\n  reachedTarget: false\n}));\n\n_defineProperty(LegIKInfo, \"blocked\", position => ({\n  legPosition: position,\n  message: `Failure. The ground is blocking the path. The target point can only be reached it by digging the ground. (${position})`,\n  obtainedSolution: false,\n  reachedTarget: true\n}));\n\n_defineProperty(LegIKInfo, \"femurTooLong\", position => ({\n  legPosition: position,\n  message: `Failure. Femur length too long. (${position})`,\n  obtainedSolution: false,\n  reachedTarget: false\n}));\n\n_defineProperty(LegIKInfo, \"tibiaTooLong\", position => ({\n  legPosition: position,\n  message: `Failure. Tibia length too long. (${position})`,\n  obtainedSolution: false,\n  reachedTarget: false\n}));\n\n_defineProperty(LegIKInfo, \"initialized\", position => ({\n  legPosition: position,\n  obtainedSolution: false,\n  reachedTarget: false,\n  message: `Haven't solved anything yet. (${position})`\n}));\n\n\n\n//# sourceURL=webpack://hexapod/./src/hexapod/solvers/ik/IKInfo.js?");

/***/ }),

/***/ "./src/hexapod/solvers/ik/IKSolver.js":
/*!********************************************!*\
  !*** ./src/hexapod/solvers/ik/IKSolver.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _LinkageIKSolver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LinkageIKSolver */ \"./src/hexapod/solvers/ik/LinkageIKSolver.js\");\n/* harmony import */ var _HexapodSupportCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HexapodSupportCheck */ \"./src/hexapod/solvers/ik/HexapodSupportCheck.js\");\n/* harmony import */ var _IKInfo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IKInfo */ \"./src/hexapod/solvers/ik/IKInfo.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../constants */ \"./src/hexapod/constants.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../geometry */ \"./src/hexapod/geometry.js\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n/* * *\n\n.......\nGiven:\n.......\n\n{}. Dimensions of each leg { femur, tibia, gamma }\n[] bodyContactPoints\n[] groundContactPoints\n   - there are two lists which contains six items each. One item for each leg.\n{} axes { xAxis, zAxis }\n   xAxis and zAxis of the rotated hexapod's local coordinate frame wrt\n   world coordinate frame.\n\n.......\nDefinition:\n.......\n\nbodyContactPoint (x, y, z)\n- The point in 3d space which is a vertex of the hexagon.\n  This is where the leg is in contact with the body of the hexapod.\n\ngroundContactPoint (x, y, z)\n- The point in 3d space which we want the foot tip of\n  the leg to be. Where the leg is in contact with the ground plane of the world.\n\n.......\nFind:\n.......\n\n18 angles that represent the pose of the hexapod. Three angles for each leg.\n    {\n      rightMiddle: { alpha, beta, gamma },\n      ...\n      rightBack: { alpha, beta, gamma },\n    }\n\n    If no solution is found, make sure to explain why.\n\n.......\nAlgorithm:\n.......\n\nIf one of the vertices is below the ground z < 0,\nthen there is no solution. Early exit.\n\nFor each leg:\n    1. Derive a few properties about the leg given what you already know\n       which you'd later (see computeInitialProperties() for details )\n\n       This includes the coxiaPoint. If this coxiaPoint is below the ground\n        - then there is no solution. Early exit.\n\n    2. Compute the alpha of this leg. see (computeAlpha())\n       If alpha is not within range, then there is no solution. Early exit.\n\n    3. Solve for beta and gamma of this leg (see LegIKSolver module)\n      If a problem was encountered within this module, then there is no solution. Early exit.\n      If the beta and gamma are not within range, then there is no solution, early exit.\n\n    4. Sometimes the LegIKSolver module would return a solution where the leg\n       would not reach the target ground contact point. (this leg would be on the air)\n       If the combination of the legs in the air would produce an unstable pose\n       (e.g 4 legs are in the air or all left legs are in the air)\n       Then there is no solution. Early exit.\n       (see also HexapodSupportChecker)\n\n    If no problems are encountered, we have found a solution! Return!\n\n* * */\n\nclass IKSolver {\n  constructor() {\n    _defineProperty(this, \"params\", {});\n\n    _defineProperty(this, \"partialPose\", {});\n\n    _defineProperty(this, \"pose\", {});\n\n    _defineProperty(this, \"foundSolution\", false);\n\n    _defineProperty(this, \"legPositionsOffGround\", []);\n\n    _defineProperty(this, \"message\", _IKInfo__WEBPACK_IMPORTED_MODULE_2__[\"IKMessage\"].initialized);\n  }\n\n  solve(legDimensions, bodyContactPoints, groundContactPoints, axes) {\n    // prettier-ignore\n    this.params = {\n      bodyContactPoints,\n      groundContactPoints,\n      axes,\n      legDimensions\n    };\n\n    if (this._hasBadVertex(bodyContactPoints)) {\n      return this;\n    }\n\n    const {\n      coxia,\n      femur,\n      tibia\n    } = legDimensions;\n\n    for (let i = 0; i < _constants__WEBPACK_IMPORTED_MODULE_3__[\"NUMBER_OF_LEGS\"]; i++) {\n      const legPosition = _constants__WEBPACK_IMPORTED_MODULE_3__[\"POSITION_NAMES_LIST\"][i]; // prettier-ignore\n\n      const known = computeInitialLegProperties(bodyContactPoints[i], groundContactPoints[i], axes.zAxis);\n\n      if (known.coxiaPoint.z < 0) {\n        this._handleBadPoint(known.coxiaPoint);\n\n        return this;\n      }\n\n      const legXaxisAngle = _constants__WEBPACK_IMPORTED_MODULE_3__[\"POSITION_NAME_TO_AXIS_ANGLE_MAP\"][legPosition]; // prettier-ignore\n\n      let alpha = computeAlpha(known.coxiaUnitVector, legXaxisAngle, axes.xAxis, axes.zAxis);\n\n      if (Math.abs(alpha) > _constants__WEBPACK_IMPORTED_MODULE_3__[\"MAX_ANGLES\"].alpha) {\n        // prettier-ignore\n        this._finalizeFailure(_IKInfo__WEBPACK_IMPORTED_MODULE_2__[\"IKMessage\"].alphaNotInRange(legPosition, alpha, _constants__WEBPACK_IMPORTED_MODULE_3__[\"MAX_ANGLES\"].alpha));\n\n        return this;\n      } // prettier-ignore\n\n\n      const solvedLegParams = new _LinkageIKSolver__WEBPACK_IMPORTED_MODULE_0__[\"default\"](legPosition).solve(coxia, femur, tibia, known.summa, known.rho);\n\n      if (!solvedLegParams.obtainedSolution) {\n        this._finalizeFailure(_IKInfo__WEBPACK_IMPORTED_MODULE_2__[\"IKMessage\"].badLeg(solvedLegParams.message));\n\n        return this;\n      }\n\n      if (!solvedLegParams.reachedTarget) {\n        if (this._hasNoMoreSupport(legPosition)) {\n          return this;\n        }\n      } // prettier-ignore\n\n\n      this.partialPose[legPosition] = {\n        alpha,\n        beta: solvedLegParams.beta,\n        gamma: solvedLegParams.gamma\n      };\n    }\n\n    this._finalizeSuccess();\n\n    return this;\n  }\n\n  get hasLegsOffGround() {\n    return this.legPositionsOffGround.length > 0 ? true : false;\n  }\n\n  _hasNoMoreSupport(legPosition) {\n    this.legPositionsOffGround.push(legPosition);\n    const [noSupport, reason] = _HexapodSupportCheck__WEBPACK_IMPORTED_MODULE_1__[\"default\"].checkSupport(this.legPositionsOffGround);\n\n    if (noSupport) {\n      const message = _IKInfo__WEBPACK_IMPORTED_MODULE_2__[\"IKMessage\"].noSupport(reason, this.legPositionsOffGround);\n\n      this._finalizeFailure(message);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  _handleBadPoint(point) {\n    this._finalizeFailure(_IKInfo__WEBPACK_IMPORTED_MODULE_2__[\"IKMessage\"].badPoint(point));\n  }\n\n  _hasBadVertex(bodyContactPoints) {\n    for (let i = 0; i < _constants__WEBPACK_IMPORTED_MODULE_3__[\"NUMBER_OF_LEGS\"]; i++) {\n      const vertex = bodyContactPoints[i];\n\n      if (vertex.z < 0) {\n        this._handleBadPoint(vertex);\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _finalizeFailure(message) {\n    this.message = message;\n    this.foundSolution = false;\n  }\n\n  _finalizeSuccess() {\n    this.pose = this.partialPose;\n    this.foundSolution = true;\n\n    if (!this.hasLegsOffGround) {\n      this.message = _IKInfo__WEBPACK_IMPORTED_MODULE_2__[\"IKMessage\"].success;\n      return;\n    }\n\n    this.message = _IKInfo__WEBPACK_IMPORTED_MODULE_2__[\"IKMessage\"].successLegsOnAir(this.legPositionsOffGround);\n  }\n\n}\n/* * *\n\ncomputeInitialLegProperties()\n\n.......\nGiven:\n.......\n\n1. pB : bodyContactPoint in 3d space\n2. pG : groundContactPoint in 3d space\n3. coxia: distance from pB to pC\n4. zAxis: The vector normal to the hexapodBodyPlane\n\n.......\nFind:\n.......\n\n1. pC : coxiaPoint in 3d space\n2. coxiaVector: the vector from pB to Pc with a length of one\n3. coxiaUnitVector: A vector with the length of one\n    pointing at the direction of the unit vector\n4. rho: The angle made by pC, pB and pG, with pB at the center\n5. summa: The distance from pB to pG\n\npB   pC\n *---* -------- hexapodBodyPlane\n  \\   \\\n   \\   *\n    \\  /\n      * ------- groundPlane\n      pG\n\n.......\nIdea:\n.......\n\n1. Get the vector from pB to pG (bodyToFootVector)\n2. Project that vector to the hexapodBodyPlane (coxiaDirectionVector)\n   The direction of this vector is the direction of\n   coxiaVector and coxiaUnitVector\n\n   And with a little bit of geometry you derive verything you need.\n\n * * */\n\n\nconst computeInitialLegProperties = (bodyContactPoint, groundContactPoint, zAxis, coxia) => {\n  const bodyToFootVector = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__[\"vectorFromTo\"])(bodyContactPoint, groundContactPoint);\n  const coxiaDirectionVector = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__[\"projectedVectorOntoPlane\"])(bodyToFootVector, zAxis);\n  const coxiaUnitVector = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__[\"getUnitVector\"])(coxiaDirectionVector);\n  const coxiaVector = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__[\"scaleVector\"])(coxiaUnitVector, coxia);\n  const coxiaPoint = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__[\"addVectors\"])(bodyContactPoint, coxiaVector);\n  const rho = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__[\"angleBetween\"])(coxiaUnitVector, bodyToFootVector);\n  const summa = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__[\"vectorLength\"])(bodyToFootVector);\n  return {\n    coxiaUnitVector,\n    coxiaVector,\n    coxiaPoint,\n    rho,\n    summa\n  };\n};\n/* * *\n\ncomputeAlpha()\n\n  hexapodYaxis\n  ^\n  |\n  * --> hexapodXaxis (xAxis)\n /\nhexapodZaxis (zAxis)\n\n...............\nExample #1 :\n...............\n\n             coxiaVector\n              ^\n              | legXaxis\n              |  /        * legXaxisAngle\n              | /            - Angle between legXaxis and hexapodXaxis\n    * -- * -- *                (in this example: +45 degrees )\n   /           \\\n  /             \\          * Alpha\n *       *       *            - Angle between legXaxis and coxiaVector\n  \\             /                (in this example: +45 degrees)\n   \\           /\n    * -- * -- *\n\n...............\nExample #2\n...............\n\n    * -- * -- *       * legXaxisAngle\n   /           \\          - (in this example: -45 degrees or +315 degrees)\n  /             \\      * Alpha\n *       *       *         - (in this example: -45 degrees)\n  \\             /\n   \\           /\n    * -- * -- *\n              |\\              - (in this example: +45 degrees )\n              | \\\n              | legXaxis\n              V\n              coxiaVector\n * * */\n\n\nconst computeAlpha = (coxiaVector, legXaxisAngle, xAxis, zAxis) => {\n  const sign = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__[\"isCounterClockwise\"])(coxiaVector, xAxis, zAxis) ? -1 : 1;\n  const alphaWrtHexapod = sign * Object(_geometry__WEBPACK_IMPORTED_MODULE_4__[\"angleBetween\"])(coxiaVector, xAxis);\n  const alpha = (alphaWrtHexapod - legXaxisAngle) % 360;\n\n  if (alpha > 180) {\n    return alpha - 360;\n  }\n\n  if (alpha < -180) {\n    return alpha + 360;\n  } // THIS IS A HACK \n  // THERE IS A BUG HERE SOMEWHERE, FIND IT\n\n\n  if (alpha === 180 || alpha === -180) {\n    return 0;\n  }\n\n  return alpha;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (IKSolver);\n\n//# sourceURL=webpack://hexapod/./src/hexapod/solvers/ik/IKSolver.js?");

/***/ }),

/***/ "./src/hexapod/solvers/ik/LinkageIKSolver.js":
/*!***************************************************!*\
  !*** ./src/hexapod/solvers/ik/LinkageIKSolver.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Vector */ \"./src/hexapod/Vector.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ \"./src/hexapod/geometry.js\");\n/* harmony import */ var _IKInfo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IKInfo */ \"./src/hexapod/solvers/ik/IKInfo.js\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* *\n\nALIASES:\n    p0: bodyContactPoint (local)\n    p1: coxaPoint (local)\n    p2: femurPoint (local)\n    p3: footTipPoint (local)\n\n           p2x'\n           /\n          /          GIVEN:\n         * p2         * (coxia) distance from p0 to p1\n        /|            * (femur) distance from p1 to p2\n       / |            * (tibia) distance from p2 to p3\np0  p1/  |            * (summa) distance from p0 to p3\n *---*   | ---> p1x'_  * rho: angle between\n  \\   \\  |                 -> p0 to p1 and p0 to p3\n    \\  \\ |            * p0 is (0, 0, 0)\n      \\ \\|            * p0 to p1 vector is inline with legXaxis\n        * p3\n                    INTERMEDIATE:\nlegZaxis              * (pars) distance from p1 to p3\n ^                    * theta: angle between\n |                          -> p1 to p2 and p1 and p3\n * - > legXaxis       * phi: angle between\n                            -> p1 to p3 and p1 to p1x'_ (legXaxis)\n                      * epsi: angle between\n                            -> p2 to p1 and p2 to p3\n\nFIND: (counter clockwise is positive)\n  * beta: Angle betweenlegXaxis and p1 to p2\n          beta > 0 if p1 to p2 is above legXaxis\n          beta < 0 if p1 to p2 is below the legXaxis\n  * gamma: Angle between p1 to p2 and axis perpendicular to p1 p2\n\nEXAMPLE: When p0, p2, p3, and p3 are configured this way then:\n    * p2 to p3z' axis is 180 degrees wrt legZaxis\n    * beta = 0\n    * gamma = +90\n\np0   p1   p2   p3\n*----*----*----*\n          |\n          |\n          V p3z'\n\n * */\n\n\n\n\nclass LinkageIKSolver {\n  // { legPosition, obtainedSolution, reachedTarget, message }\n  constructor(legPosition) {\n    _defineProperty(this, \"info\", void 0);\n\n    _defineProperty(this, \"vectors\", {\n      legXaxis: new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](1, 0, 0, \"legXaxis\"),\n      parsVector: null\n    });\n\n    _defineProperty(this, \"points\", {\n      bodyContactPoint: null,\n      coxiaPoint: null,\n      targetFootTipPoint: null\n    });\n\n    _defineProperty(this, \"dimensions\", {\n      coxia: 0,\n      femur: 0,\n      tibia: 0,\n      summa: 0,\n      pars: 0\n    });\n\n    _defineProperty(this, \"angles\", {\n      beta: null,\n      gamma: null,\n      rho: null\n    });\n\n    this.info = _IKInfo__WEBPACK_IMPORTED_MODULE_2__[\"LegIKInfo\"].initialized(legPosition);\n  }\n\n  solve(coxia, femur, tibia, summa, rho) {\n    this.angles.rho = rho;\n    this.dimensions = {\n      coxia,\n      femur,\n      tibia,\n      summa\n    };\n    const coxiaPoint = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](coxia, 0, 0, \"coxiaPoint\");\n\n    const targetFootTipPoint = this._computeTargetFootTipPoint();\n\n    const parsVector = Object(_geometry__WEBPACK_IMPORTED_MODULE_1__[\"vectorFromTo\"])(coxiaPoint, targetFootTipPoint);\n    const pars = Object(_geometry__WEBPACK_IMPORTED_MODULE_1__[\"vectorLength\"])(parsVector);\n    this.dimensions.pars = pars;\n    this.points = { ...this.points,\n      coxiaPoint,\n      targetFootTipPoint\n    };\n    this.vectors = { ...this.vectors,\n      parsVector\n    };\n    Object(_geometry__WEBPACK_IMPORTED_MODULE_1__[\"isTriangle\"])(pars, femur, tibia) ? this._handleCaseTriangleCanForm() : this._handleEdgeCase();\n    return this;\n  }\n\n  get legPosition() {\n    return this.info.legPosition;\n  }\n\n  get beta() {\n    return this.angles.beta;\n  }\n\n  get gamma() {\n    return this.angles.gamma;\n  }\n\n  get obtainedSolution() {\n    return this.info.obtainedSolution;\n  }\n\n  get reachedTarget() {\n    return this.info.reachedTarget;\n  }\n\n  get message() {\n    return this.info.message;\n  }\n\n  _computeTargetFootTipPoint() {\n    const [summa, rho] = [this.dimensions.summa, this.angles.rho];\n    const px = summa * Math.cos(Object(_geometry__WEBPACK_IMPORTED_MODULE_1__[\"radians\"])(rho));\n    const pz = -summa * Math.sin(Object(_geometry__WEBPACK_IMPORTED_MODULE_1__[\"radians\"])(rho));\n    return new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](px, 0, pz, \"targetLocalFootTipPoint\");\n  }\n\n  _handleCaseTriangleCanForm() {\n    const {\n      femur,\n      pars,\n      tibia\n    } = this.dimensions;\n    const {\n      parsVector,\n      legXaxis\n    } = this.vectors;\n    const {\n      targetFootTipPoint\n    } = this.points;\n    const theta = Object(_geometry__WEBPACK_IMPORTED_MODULE_1__[\"angleOppositeOfLastSide\"])(femur, pars, tibia);\n    const phi = Object(_geometry__WEBPACK_IMPORTED_MODULE_1__[\"angleBetween\"])(parsVector, legXaxis);\n    const beta = targetFootTipPoint.z < 0 ? theta - phi : theta + phi;\n    const epsi = Object(_geometry__WEBPACK_IMPORTED_MODULE_1__[\"angleOppositeOfLastSide\"])(femur, tibia, pars);\n    const femurPointZ = femur * Math.sin(Object(_geometry__WEBPACK_IMPORTED_MODULE_1__[\"radians\"])(beta));\n    this.angles.beta = beta;\n\n    if (targetFootTipPoint.z > femurPointZ) {\n      this.info = _IKInfo__WEBPACK_IMPORTED_MODULE_2__[\"LegIKInfo\"].blocked(this.legPosition);\n      return;\n    }\n\n    this.angles.gamma = epsi - 90;\n    this.info = _IKInfo__WEBPACK_IMPORTED_MODULE_2__[\"LegIKInfo\"].targetReached(this.legPosition);\n  }\n\n  _handleEdgeCase() {\n    const {\n      pars,\n      tibia,\n      femur\n    } = this.dimensions;\n\n    if (pars + tibia < femur) {\n      this.info = _IKInfo__WEBPACK_IMPORTED_MODULE_2__[\"LegIKInfo\"].femurTooLong(this.legPosition);\n      return;\n    }\n\n    if (pars + femur < tibia) {\n      console.log(this.info.legPosition);\n      this.info = _IKInfo__WEBPACK_IMPORTED_MODULE_2__[\"LegIKInfo\"].tibiaTooLong(this.legPosition);\n      return;\n    } // then femur + tibia < pars\n    //\n    // p0 *---* p1     * stretch to try to reach target\n    //         \\       * gamma:\n    //          * p2      => 90: stretch, 0: curl down, 180: curl up\n    //           \\\n    //            * p3 (actual when stretched)\n    //\n    //              * targetp3\n    //\n\n\n    const {\n      parsVector,\n      legXaxis\n    } = this.vectors;\n    this.angles = { ...this.angles,\n      beta: -Object(_geometry__WEBPACK_IMPORTED_MODULE_1__[\"angleBetween\"])(parsVector, legXaxis),\n      gamma: 90\n    };\n    this.info = _IKInfo__WEBPACK_IMPORTED_MODULE_2__[\"LegIKInfo\"].targetNotReached(this.legPosition);\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (LinkageIKSolver);\n\n//# sourceURL=webpack://hexapod/./src/hexapod/solvers/ik/LinkageIKSolver.js?");

/***/ }),

/***/ "./src/hexapod/solvers/ik/hexapodSolver.js":
/*!*************************************************!*\
  !*** ./src/hexapod/solvers/ik/hexapodSolver.js ***!
  \*************************************************/
/*! exports provided: default, solveHexapodParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"solveHexapodParams\", function() { return solveHexapodParams; });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants */ \"./src/hexapod/constants.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ \"./src/hexapod/geometry.js\");\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Vector */ \"./src/hexapod/Vector.js\");\n/* harmony import */ var _VirtualHexapod__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../VirtualHexapod */ \"./src/hexapod/VirtualHexapod.js\");\n/* harmony import */ var _IKSolver__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./IKSolver */ \"./src/hexapod/solvers/ik/IKSolver.js\");\n\n\n\n\n\n\nconst solveInverseKinematics = (dimensions, rawIKparams, flags = {\n  rotateThenShift: true\n}) => {\n  const [ikSolver, target_groundContactPoints] = solveHexapodParams(dimensions, rawIKparams, flags.rotateThenShift);\n\n  if (!ikSolver.foundSolution) {\n    return {\n      pose: null,\n      obtainedSolution: false,\n      message: ikSolver.message,\n      hexapod: null\n    };\n  } // How the hexapod looks like if the center of gravity is at (0, 0, _)\n\n\n  const currentHexapod = new _VirtualHexapod__WEBPACK_IMPORTED_MODULE_3__[\"default\"](dimensions, ikSolver.pose);\n  const excludedPositions = ikSolver.legPositionsOffGround;\n  const pivots = findTwoPivotPoints(currentHexapod.groundContactPoints, target_groundContactPoints, excludedPositions);\n  const hexapod = pivots.foundTwoPoints ? rotateShiftHexapodgivenPivots(currentHexapod, pivots.points1, pivots.points2) : currentHexapod;\n  return {\n    pose: ikSolver.pose,\n    obtainedSolution: true,\n    message: ikSolver.message,\n    hexapod\n  };\n};\n/* * *\n    Returns a two-element array\n    1. ikSolver: IKSolver object\n    2. An array of target ground contact points\n * * */\n\n\nconst solveHexapodParams = (dimensions, rawIKparams, rotateThenShift) => {\n  const {\n    tVec,\n    rotMatrix,\n    startPose\n  } = convertIKparams(dimensions, rawIKparams);\n  const startHexapod = new _VirtualHexapod__WEBPACK_IMPORTED_MODULE_3__[\"default\"](dimensions, startPose);\n  const targets = buildHexapodTargets(startHexapod, rotMatrix, tVec, {\n    rotateThenShift\n  }); // Solve for the pose of the hexapod if it exists\n\n  const ikSolver = new _IKSolver__WEBPACK_IMPORTED_MODULE_4__[\"default\"]().solve(startHexapod.legDimensions, targets.bodyContactPoints, targets.groundContactPoints, targets.axes);\n  return [ikSolver, targets.groundContactPoints];\n}; // Make sure all parameter values are numbers\n\n\nconst rawParamsToNumbers = rawParams => Object.entries(rawParams).reduce((params, [key, val]) => ({ ...params,\n  [key]: Number(val)\n}), {}); // tx, ty, and tz are within the range of (-1, 1)\n// return the actual values we want the hexapod's center of gravity to be at\n\n\nconst convertFromPercentToTranslateValues = (tx, ty, tz, middle, side, tibia) => {\n  const shiftX = tx * middle;\n  const shiftY = ty * side;\n  const shiftZ = tz * tibia;\n  return new _Vector__WEBPACK_IMPORTED_MODULE_2__[\"default\"](shiftX, shiftY, shiftZ);\n};\n/* * *\n\nstartPose:\n    - The pose of the hexapod before we\n        rotate and translate the hexapod\n    - The body (hexagon) is flat at this point\n    - At the very end, we want the hexapod\n        to step on the same place as at this pose\n        (ie same ground contact points)\n\n * * */\n\n\nconst buildStartPose = (hipStance, legStance) => {\n  const betaAndGamma = {\n    beta: legStance,\n    gamma: -legStance\n  };\n  const alphas = [0, -hipStance, hipStance, 0, -hipStance, hipStance];\n  return alphas.reduce((pose, alpha, index) => {\n    const positionName = _constants__WEBPACK_IMPORTED_MODULE_0__[\"POSITION_NAMES_LIST\"][index];\n    pose[positionName] = {\n      alpha,\n      ...betaAndGamma\n    };\n    return pose;\n  }, {});\n};\n/* * *\n\ncompute for the following:\n\nstartPose:\n    - The pose of the hexapod before we\n        rotate and translate the hexapod\n    - see function buildStartPose() for details\n\nrotateMatrix:\n    - The transformation matrix we would use to\n        rotate the hexapod's body\n\ntVec\n    - The translation vector we would use to\n        shift the hexapod's body\n\n * * */\n\n\nconst convertIKparams = (dimensions, rawIKparams) => {\n  const IKparams = rawParamsToNumbers(rawIKparams);\n  const {\n    middle,\n    side,\n    tibia\n  } = dimensions;\n  const {\n    tx,\n    ty,\n    tz\n  } = IKparams; // prettier-ignore\n\n  const tVec = convertFromPercentToTranslateValues(tx, ty, tz, middle, side, tibia);\n  const {\n    hipStance,\n    legStance\n  } = IKparams;\n  const startPose = buildStartPose(hipStance, legStance);\n  const {\n    rx,\n    ry,\n    rz\n  } = IKparams;\n  const rotMatrix = Object(_geometry__WEBPACK_IMPORTED_MODULE_1__[\"tRotXYZmatrix\"])(rx, ry, rz);\n  return {\n    tVec,\n    startPose,\n    rotMatrix\n  };\n};\n/* * *\n\ncompute the parameters required to solve\nfor the hexapod's inverse kinematics\n\nsee IKSolver() class for details.\n\n * * */\n\n\nconst buildHexapodTargets = (hexapod, rotMatrix, tVec, {\n  rotateThenShift\n}) => {\n  const groundContactPoints = hexapod.legs.map(leg => leg.maybeGroundContactPoint);\n  const bodyContactPoints = rotateThenShift ? hexapod.body.cloneTrot(rotMatrix).cloneShift(tVec.x, tVec.y, tVec.z).verticesList : hexapod.body.cloneShift(tVec.x, tVec.y, tVec.z).cloneTrot(rotMatrix).verticesList;\n  const axes = {\n    xAxis: new _Vector__WEBPACK_IMPORTED_MODULE_2__[\"default\"](1, 0, 0).cloneTrot(rotMatrix),\n    zAxis: new _Vector__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 1).cloneTrot(rotMatrix)\n  };\n  return {\n    groundContactPoints,\n    bodyContactPoints,\n    axes\n  };\n};\n/* * *\n\nWe know 2 point positions that we know are\nfoot tip ground contact points\n(position ie \"rightMiddle\" etc)\n\nThe given `hexapod` is stepping at the `current` points\n\nWe want to return a hexapod that is\nshifted and rotated it so that those\ntwo points would be stepping at their\nrespective `target` points\n\n * * */\n\n\nconst rotateShiftHexapodgivenPivots = (hexapod, points1, points2) => {\n  const targetVector = Object(_geometry__WEBPACK_IMPORTED_MODULE_1__[\"vectorFromTo\"])(points1.target, points2.target);\n  const currentVector = Object(_geometry__WEBPACK_IMPORTED_MODULE_1__[\"vectorFromTo\"])(points1.current, points2.current);\n  const twistAngleAbsolute = Object(_geometry__WEBPACK_IMPORTED_MODULE_1__[\"angleBetween\"])(currentVector, targetVector);\n  const isCCW = Object(_geometry__WEBPACK_IMPORTED_MODULE_1__[\"isCounterClockwise\"])(currentVector, targetVector, new _Vector__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 1));\n  const twistAngle = isCCW ? twistAngleAbsolute : -twistAngleAbsolute;\n  const twistMatrix = Object(_geometry__WEBPACK_IMPORTED_MODULE_1__[\"tRotZmatrix\"])(twistAngle);\n  const twistedCurrentPoint1 = points1.current.cloneTrot(twistMatrix);\n  const translateVector = Object(_geometry__WEBPACK_IMPORTED_MODULE_1__[\"vectorFromTo\"])(twistedCurrentPoint1, points1.target);\n  const pivotedHexapod = hexapod.cloneTrot(twistMatrix).cloneShift(translateVector.x, translateVector.y, 0);\n  return pivotedHexapod;\n};\n/* * *\n\ngiven the points where the hexapod should step on\n\nFind two foot tips as pivot points\nthat we can use to shift and twist the current Hexapod\n\n * * */\n\n\nconst findTwoPivotPoints = (currentPoints, targetPoints, excludedPositions) => {\n  const targetPointsMap = targetPoints.reduce((acc, point) => {\n    acc[point.name] = point;\n    return acc;\n  }, {});\n  const targetPointNames = Object.keys(targetPointsMap);\n  let [currentPoint1, currentPoint2] = [null, null];\n  let [targetPoint1, targetPoint2] = [null, null];\n\n  for (let i = 0; i < currentPoints.length; i++) {\n    const currentPoint = currentPoints[i];\n    const currentName = currentPoint.name;\n\n    if (excludedPositions.includes(currentName)) {\n      continue;\n    }\n\n    if (targetPointNames.includes(currentName)) {\n      if (currentPoint1 === null) {\n        currentPoint1 = currentPoint;\n        targetPoint1 = targetPointsMap[currentName];\n      } else {\n        currentPoint2 = currentPoint;\n        targetPoint2 = targetPointsMap[currentName];\n        break;\n      }\n    }\n  }\n\n  if (currentPoint2 === null) {\n    return {\n      foundTwoPoints: false\n    };\n  }\n\n  return {\n    points1: {\n      target: targetPoint1,\n      current: currentPoint1\n    },\n    points2: {\n      target: targetPoint2,\n      current: currentPoint2\n    },\n    foundTwoPoints: true\n  };\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (solveInverseKinematics);\n\n\n//# sourceURL=webpack://hexapod/./src/hexapod/solvers/ik/hexapodSolver.js?");

/***/ }),

/***/ "./src/hexapod/solvers/orient/orientSolverGeneral.js":
/*!***********************************************************!*\
  !*** ./src/hexapod/solvers/orient/orientSolverGeneral.js ***!
  \***********************************************************/
/*! exports provided: computeOrientationProperties */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeOrientationProperties\", function() { return computeOrientationProperties; });\n/* harmony import */ var _orientSolverHelpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./orientSolverHelpers */ \"./src/hexapod/solvers/orient/orientSolverHelpers.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ \"./src/hexapod/geometry.js\");\n/* * *\n\nA more general algorithm to account for the cases\nthat are not handled correctly by the orientSolverSpecific.\n\n- Only used by the kinematics-page of the app.\n- Can be optimized or replaced if a more elegant\nalgorithm is available.\n\n............\n  OVERVIEW\n............\n\nFind:\n- The orientation of the hexapod (normal axis of the hexapod body plane)\n- distance of hexapod center of gravity to the ground plane (height)\n- All the legs which are in contact in the ground\n\nHow?\n\nWe have 18 points total.\n(6 legs, three possible points per leg (femurPoint))\n\nWe have a total of 540 combinations\n- get three legs out of six (20 combinations)\n  - we have three possible points for each leg,\n        (coxiaPoint, femurPoint, footTip),\n        that's 27 (3^3) combinations\n  -  27 * 20 is 540\n\nFor each combination:\n    1. Check if stable. If not, try the next combination\n      - Check if the projection of the center of gravity to the plane\n        defined by the three points lies inside the triangle,\n        if not stable, try the next combination\n\n    2. Get the HEIGHT and normal of the height and normal of the triangle plane\n        (We need this for the next part)\n\n    3. For each of the three legs, check if the two other points on the leg is not\n        lower than HEIGHT, (6 points total)\n        if condition if broken, try the next combination.\n\n    4. For each of the three other legs, check if all points (3 points of each leg)\n        are not lower than HEIGHT\n        if this condition is broken, try the next combination. (9 points total)\n\n    5. If no condition is violated, then this is good, return this!\n\n * * */\n\n\n\nconst makeJointIndexTrios = () => {\n  let jointIdTrios = [];\n\n  for (let i = 3; i > 0; i--) {\n    for (let j = 3; j > 0; j--) {\n      for (let k = 3; k > 0; k--) {\n        jointIdTrios.push([i, j, k]);\n      }\n    }\n  }\n\n  return jointIdTrios;\n};\n\nconst shuffleArray = array => {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n\n  return array;\n};\n\nconst JOINT_INDEX_TRIOS = makeJointIndexTrios();\n\nconst computeOrientationProperties = (legsNoGravity, flags = {\n  shuffle: false\n}) => {\n  const someLegTrios = flags.shuffle ? shuffleArray(_orientSolverHelpers__WEBPACK_IMPORTED_MODULE_0__[\"SOME_LEG_ID_TRIOS\"].slice()) : _orientSolverHelpers__WEBPACK_IMPORTED_MODULE_0__[\"SOME_LEG_ID_TRIOS\"];\n  const legIndexTrios = [...someLegTrios, ..._orientSolverHelpers__WEBPACK_IMPORTED_MODULE_0__[\"ADJACENT_LEG_ID_TRIOS\"]];\n  let fallback = null;\n\n  for (let i = 0; i < legIndexTrios.length; i++) {\n    const threeLegIndices = legIndexTrios[i];\n    const {\n      threeLegs,\n      otherThreeLegs\n    } = getTwoLegSets(threeLegIndices, legsNoGravity);\n\n    for (let j = 0; j < JOINT_INDEX_TRIOS.length; j++) {\n      const threeJointIndices = JOINT_INDEX_TRIOS[j];\n      const [p0, p1, p2] = getThreePoints(threeLegs, threeJointIndices);\n\n      if (!Object(_orientSolverHelpers__WEBPACK_IMPORTED_MODULE_0__[\"isStable\"])(p0, p1, p2)) {\n        continue;\n      }\n\n      const normal = Object(_geometry__WEBPACK_IMPORTED_MODULE_1__[\"getNormalofThreePoints\"])(p0, p1, p2, \"normalVector\");\n      const height = -Object(_geometry__WEBPACK_IMPORTED_MODULE_1__[\"dot\"])(normal, p0);\n\n      if (anotherPointOfSameLegIsLower(threeLegs, threeJointIndices, normal, height)) {\n        continue;\n      }\n\n      if (anotherPointofOtherLegsIsLower(otherThreeLegs, normal, height)) {\n        continue;\n      } // THIS IS A HACK \n      // THERE IS A BUG HERE SOMEWHERE, FIND IT\n\n\n      if (height === 0) {\n        if (fallback === null) {\n          fallback = {\n            p0,\n            p1,\n            p2,\n            normal,\n            height\n          };\n        }\n\n        continue;\n      }\n\n      const groundLegsNoGravity = Object(_orientSolverHelpers__WEBPACK_IMPORTED_MODULE_0__[\"findLegsOnGround\"])(legsNoGravity, normal, height);\n      return {\n        nAxis: normal,\n        height,\n        groundLegsNoGravity\n      };\n    }\n  }\n\n  if (fallback === null) {\n    return null;\n  }\n\n  return {\n    nAxis: fallback.normal,\n    height: fallback.height,\n    groundLegsNoGravity: Object(_orientSolverHelpers__WEBPACK_IMPORTED_MODULE_0__[\"findLegsOnGround\"])(legsNoGravity, fallback.normal, fallback.height)\n  };\n};\n\nconst getThreePoints = (threeLegs, threeJointIndices) => threeLegs.map((leg, index) => {\n  const jointId = threeJointIndices[index];\n  return leg.allPointsList[jointId];\n});\n\nconst getTwoLegSets = (threeLegIndices, sixLegs) => {\n  const threeLegs = threeLegIndices.map(n => sixLegs[n]);\n  const otherThreeLegIndices = [...Array(6).keys()].filter(n => !threeLegIndices.includes(n));\n  const otherThreeLegs = otherThreeLegIndices.map(n => sixLegs[n]);\n  return {\n    threeLegs,\n    otherThreeLegs\n  };\n};\n\nconst anotherPointOfSameLegIsLower = (threeLegs, threeJointIndices, normal, height) => {\n  for (let i = 0; i < 3; i++) {\n    const [leg, jointIndex] = [threeLegs[i], threeJointIndices[i]];\n    const hasLower = leg.allPointsList.some((otherPoint, index) => {\n      const notBodyContact = index !== 0;\n      const notItself = index !== jointIndex;\n      return notBodyContact && notItself && Object(_orientSolverHelpers__WEBPACK_IMPORTED_MODULE_0__[\"isLower\"])(otherPoint, normal, height);\n    });\n\n    if (hasLower) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst anotherPointofOtherLegsIsLower = (otherThreeLegs, normal, height) => {\n  for (let i = 0; i < 3; i++) {\n    const leg = otherThreeLegs[i];\n    const hasLower = leg.allPointsList.slice(1).some(point => Object(_orientSolverHelpers__WEBPACK_IMPORTED_MODULE_0__[\"isLower\"])(point, normal, height));\n\n    if (hasLower) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\n\n\n//# sourceURL=webpack://hexapod/./src/hexapod/solvers/orient/orientSolverGeneral.js?");

/***/ }),

/***/ "./src/hexapod/solvers/orient/orientSolverHelpers.js":
/*!***********************************************************!*\
  !*** ./src/hexapod/solvers/orient/orientSolverHelpers.js ***!
  \***********************************************************/
/*! exports provided: SOME_LEG_ID_TRIOS, ADJACENT_LEG_ID_TRIOS, isStable, isLower, findLegsOnGround */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SOME_LEG_ID_TRIOS\", function() { return SOME_LEG_ID_TRIOS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ADJACENT_LEG_ID_TRIOS\", function() { return ADJACENT_LEG_ID_TRIOS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isStable\", function() { return isStable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isLower\", function() { return isLower; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findLegsOnGround\", function() { return findLegsOnGround; });\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ \"./src/hexapod/geometry.js\");\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Vector */ \"./src/hexapod/Vector.js\");\n\n\n\nconst isLower = (point, normal, height, tol = 1) => -Object(_geometry__WEBPACK_IMPORTED_MODULE_0__[\"dot\"])(normal, point) > height + tol;\n/* *\n\n   Each leg has four points (footTip, femurPoint, coxiaPoint, bodyContact).\n   If one point of leg is at the same distance as the ground is\n   from the hexapod's center of gravity, then this leg is on the ground.\n\n   Note: we check starting from the footTip to the bodyContact because\n   the footTip is the one most likely to be on the ground\n\n * */\n\n\nconst findLegsOnGround = (legs, normal, height) => {\n  return legs.reduce((legsOnGround, leg) => {\n    const reversedPoints = leg.allPointsList.slice(1).reverse();\n    const onGround = reversedPoints.some(point => sameHeight(point, normal, height));\n    return onGround ? [...legsOnGround, leg] : legsOnGround;\n  }, []);\n};\n\nconst sameHeight = (point, normal, height, tol = 1) => {\n  const _height = -Object(_geometry__WEBPACK_IMPORTED_MODULE_0__[\"dot\"])(normal, point);\n\n  return Math.abs(height - _height) <= tol;\n};\n\nconst SOME_LEG_ID_TRIOS = [[0, 1, 3], [0, 1, 4], [0, 2, 3], [0, 2, 4], [0, 2, 5], [0, 3, 4], [0, 3, 5], [1, 2, 4], [1, 2, 5], [1, 3, 4], [1, 3, 5], [1, 4, 5], [2, 3, 5], [2, 4, 5]];\nconst ADJACENT_LEG_ID_TRIOS = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [0, 4, 5], [0, 1, 5]];\n/* *\n * Determines stability of the pose.\n * Determine if projection of 3D point cog\n * onto the plane defined by p0, p1, p2\n * is within a triangle defined by p0, p1, p2.\n * */\n\nconst isStable = (p0, p1, p2, tol = 0.001) => {\n  const cog = new _Vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, 0, 0);\n  const u = Object(_geometry__WEBPACK_IMPORTED_MODULE_0__[\"vectorFromTo\"])(p0, p1);\n  const v = Object(_geometry__WEBPACK_IMPORTED_MODULE_0__[\"vectorFromTo\"])(p0, p2);\n  const w = Object(_geometry__WEBPACK_IMPORTED_MODULE_0__[\"vectorFromTo\"])(p0, cog);\n  const n = Object(_geometry__WEBPACK_IMPORTED_MODULE_0__[\"cross\"])(u, v);\n  const n2 = Object(_geometry__WEBPACK_IMPORTED_MODULE_0__[\"dot\"])(n, n); // NOTE: alpha, beta, gamma are NOT angles\n  // cogProjected = alpha * p0 + beta * p1 + gamma * p2\n\n  const beta = Object(_geometry__WEBPACK_IMPORTED_MODULE_0__[\"dot\"])(Object(_geometry__WEBPACK_IMPORTED_MODULE_0__[\"cross\"])(u, w), n) / n2;\n  const gamma = Object(_geometry__WEBPACK_IMPORTED_MODULE_0__[\"dot\"])(Object(_geometry__WEBPACK_IMPORTED_MODULE_0__[\"cross\"])(w, v), n) / n2;\n  const alpha = 1 - beta - gamma;\n  const minVal = -tol;\n  const maxVal = 1 + tol;\n  const cond0 = minVal <= alpha && alpha <= maxVal;\n  const cond1 = minVal <= beta && beta <= maxVal;\n  const cond2 = minVal <= gamma && gamma <= maxVal;\n  return cond0 && cond1 && cond2;\n};\n\n\n\n//# sourceURL=webpack://hexapod/./src/hexapod/solvers/orient/orientSolverHelpers.js?");

/***/ }),

/***/ "./src/hexapod/solvers/orient/orientSolverSpecific.js":
/*!************************************************************!*\
  !*** ./src/hexapod/solvers/orient/orientSolverSpecific.js ***!
  \************************************************************/
/*! exports provided: computeOrientationProperties */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeOrientationProperties\", function() { return computeOrientationProperties; });\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ \"./src/hexapod/geometry.js\");\n/* harmony import */ var _orientSolverHelpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./orientSolverHelpers */ \"./src/hexapod/solvers/orient/orientSolverHelpers.js\");\n\n\nconst LEG_ID_TRIOS = [..._orientSolverHelpers__WEBPACK_IMPORTED_MODULE_1__[\"SOME_LEG_ID_TRIOS\"], ..._orientSolverHelpers__WEBPACK_IMPORTED_MODULE_1__[\"ADJACENT_LEG_ID_TRIOS\"]];\n/* *\n  .................\n  COMPUTE ORIENTATION PROPERTIES (TYPE: SPECIFIC)\n  .................\n\n  Given: 1. A list of legs with known pose and\n            its points wrt the hexapod body is known\n         2. The legs which are in contact with the ground\n            is known\n\n  Find: 1. Normal vector of the plane defined by foot tip of\n           legs on the ground wrt the hexapod body plane\n        2. Distance of the hexapod body plane to the plane\n           defined by the foot tips on the ground\n        3. Which legs are on the ground\n * */\n\nconst computeOrientationProperties = legsNoGravity => {\n  const result = computePlaneProperties(legsNoGravity);\n\n  if (result === null) {\n    return null;\n  }\n\n  const groundLegsNoGravity = Object(_orientSolverHelpers__WEBPACK_IMPORTED_MODULE_1__[\"findLegsOnGround\"])(legsNoGravity, result.normal, result.height);\n  return {\n    nAxis: result.normal,\n    height: result.height,\n    groundLegsNoGravity\n  };\n};\n/* *\n * .................\n * COMPUTE PLANE PROPERTIES\n * .................\n * */\n\n\nconst computePlaneProperties = legs => {\n  const maybeGroundContactPoints = legs.map(leg => leg.maybeGroundContactPoint);\n\n  for (let i = 0; i < LEG_ID_TRIOS.length; i++) {\n    const legTrio = LEG_ID_TRIOS[i];\n    const [p0, p1, p2] = legTrio.map(j => maybeGroundContactPoints[j]);\n\n    if (!Object(_orientSolverHelpers__WEBPACK_IMPORTED_MODULE_1__[\"isStable\"])(p0, p1, p2)) {\n      continue;\n    }\n\n    const normal = Object(_geometry__WEBPACK_IMPORTED_MODULE_0__[\"getNormalofThreePoints\"])(p0, p1, p2, \"normalVector\");\n    /* * *\n     *\n     *  cog *   ^ (normal_vector) ----\n     *       \\  |                  |\n     *        \\ |               -height\n     *         \\|                  |\n     *          V p0 (foot_tip) ---v--\n     *\n     *  using p0, p1 or p2 should yield the same height\n     *\n     * * */\n\n    const height = -Object(_geometry__WEBPACK_IMPORTED_MODULE_0__[\"dot\"])(normal, p0);\n    const otherTrio = [...Array(6).keys()].filter(j => !legTrio.includes(j));\n    const otherFootTips = otherTrio.map(j => maybeGroundContactPoints[j]);\n    const noOtherLegLower = otherFootTips.every(footTip => !Object(_orientSolverHelpers__WEBPACK_IMPORTED_MODULE_1__[\"isLower\"])(footTip, normal, height));\n\n    if (noOtherLegLower) {\n      return {\n        normal,\n        height\n      };\n    }\n  }\n\n  return null;\n};\n\n\n\n//# sourceURL=webpack://hexapod/./src/hexapod/solvers/orient/orientSolverSpecific.js?");

/***/ }),

/***/ "./src/hexapod/solvers/twistSolver.js":
/*!********************************************!*\
  !*** ./src/hexapod/solvers/twistSolver.js ***!
  \********************************************/
/*! exports provided: complexTwist, mightTwist, simpleTwist */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"complexTwist\", function() { return complexTwist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mightTwist\", function() { return mightTwist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"simpleTwist\", function() { return simpleTwist; });\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry */ \"./src/hexapod/geometry.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ \"./src/hexapod/constants.js\");\n\n\n/**\n\nmightTwist()\n    params: list of legs that are known to touch the ground\n    returns: boolean\n        false if we are sure it won't twist\n        true if there's a possibility that it might twist\n\ngiven the starting pose is such that:\n    - all alphas are zero\n    - all foot tips are touching the ground\n\nthen the hexapod will only twist if:\n    - ATLEAST three alphas of the legs touching the ground\n    - the point of contact of these legs are foot tips\n    - All the twist must be only in one directions\n      ie: the threes alphas are either all positive or all negative\n      (NOT a mix of both)\n\nIt will definitely not twist if:\n    - If only two or less of the legs has an alpha !== 0\n    - less than three alphas are twisting towards one direction\n\n **/\n\nconst mightTwist = legsOnGround => {\n  let negativeAlphaCount = 0;\n  let positiveAlphaCount = 0;\n\n  for (let i = 0; i < legsOnGround.length; i++) {\n    const leg = legsOnGround[i];\n    const pointType = leg.maybeGroundContactPoint.name.split(\"-\")[1];\n    const footTipIsOnGround = pointType === \"footTipPoint\";\n    const changedAlpha = leg.pose.alpha !== 0;\n\n    if (footTipIsOnGround && changedAlpha) {\n      leg.pose.alpha > 0 ? positiveAlphaCount++ : negativeAlphaCount++;\n    }\n  }\n\n  return positiveAlphaCount >= 3 || negativeAlphaCount >= 3;\n};\n/* *\n\ncomplexTwist()\n\nParams:\n\ndefaultPoints:\n    This is the list of the six points which are on the ground\n    when a hexapod of the same dimensions has the default pose\n    (all angles == 0 ), because it is that pose all of these points\n    are of type footTipPoint\n\ncurrentPoints:\n    This are the list of points (NOT necessarily six and\n    NOT necessarily footTipPoints) that will be on the ground\n    when a hexapod of this dimensions is on a specified pose\n    BUT is NOT rotated twisted along the zAxis\n\nFind:\n    The angle about the zAxis that the hexapod would rotate\n    assuming that the hexapod will start with the\n    default pose (which the defaultPoints would be the ground\n    contact points)\n    and will end at the specified pose (which would\n    result the currentPoints as the ground contact points\n    if the hexapod is not twisted about the zAxis).\n\nAlgorithm:\n    Find a point that is on the ground at\n    the current pose, and at the default pose.\n    (samePointPosition)\n\n    Find the angle to align that currentPoint\n    to the defaultPoint.\n\n    (this means that the hexapod would have twisted about its zAxis\n    so that the point in the ground in this legPosition\n    is the same before (default pose) and after\n    (current pose) moving to the current pose)\n * */\n\n\nconst complexTwist = (currentPoints, defaultPoints) => {\n  const currentSamePoint = currentPoints.find(point => {\n    const pointType = point.name.split(\"-\")[1];\n    return pointType === \"footTipPoint\";\n  });\n\n  if (currentSamePoint === undefined) {\n    return 0;\n  }\n\n  const samePointPosition = currentSamePoint.name.split(\"-\")[0];\n  const samePointIndex = _constants__WEBPACK_IMPORTED_MODULE_1__[\"POSITION_NAME_TO_ID_MAP\"][samePointPosition];\n  const defaultSamePoint = defaultPoints[samePointIndex];\n  const thetaRadians = Math.atan2(defaultSamePoint.y, defaultSamePoint.x) - Math.atan2(defaultSamePoint.y, defaultSamePoint.x);\n  return Object(_geometry__WEBPACK_IMPORTED_MODULE_0__[\"degrees\"])(thetaRadians);\n};\n/**\n\nsimpleTwist()\n\nWe twist in the condition that:\n  - All the legs pose has same alpha\n  - the ground contact points are either all femurPoints or all footTipPoints\n   if all femurPoints on ground, make sure bodyContactPoint.z != femurPoint.z\n    (ie  if hexapod body is not on the ground we should not twist)\n\n**/\n\n\nconst simpleTwist = groundLegsNoGravity => {\n  const firstLeg = groundLegsNoGravity[0];\n  const allSameAlpha = groundLegsNoGravity.every(leg => leg.pose.alpha === firstLeg.pose.alpha);\n\n  if (!allSameAlpha) {\n    return 0;\n  }\n\n  const allPointTypes = groundLegsNoGravity.map(leg => leg.maybeGroundContactPoint.name.split(\"-\")[1]);\n  const firstPointType = allPointTypes[0];\n  const allPointsSameType = allPointTypes.every(pointType => {\n    return pointType === firstPointType;\n  });\n\n  if (!allPointsSameType) {\n    return 0;\n  } // at this point, all ground points are of the same type\n\n\n  if ([\"coxiaPoint\", \"bodyContactPoint\"].includes(firstPointType)) {\n    return 0;\n  } // at this point, all ground points are either ALL femurPoint or ALL footTipPoint\n\n\n  if (firstPointType === \"femurPoint\") {\n    const hexapodBodyPlaneOnGround = firstLeg.bodyContactPoint.z === firstLeg.femurPoint.z;\n\n    if (hexapodBodyPlaneOnGround) {\n      return 0;\n    }\n  }\n\n  return -firstLeg.pose.alpha;\n};\n\n\n\n//# sourceURL=webpack://hexapod/./src/hexapod/solvers/twistSolver.js?");

/***/ }),

/***/ "./src/hexapod/solvers/walkSequenceSolver.js":
/*!***************************************************!*\
  !*** ./src/hexapod/solvers/walkSequenceSolver.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ik_hexapodSolver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ik/hexapodSolver */ \"./src/hexapod/solvers/ik/hexapodSolver.js\");\n\n/* * *\n\nReturn format:\n  poseSequence = {\n    leftMiddle: {\n        alpha: [],\n        beta: [],\n        gamma: [],\n    }\n    ....\n  }\n\n  gaitType = [\"ripple\", \"tripod\"]\n  walkMode = [\"rotating\", \"walking\"]\n  * * */\n\nconst getWalkSequence = (dimensions, params = {\n  tx: 0,\n  tz: 0,\n  rx: 0,\n  ry: 0,\n  legStance: 0,\n  hipStance: 25,\n  stepCount: 5,\n  hipSwing: 25,\n  liftSwing: 40\n}, gaitType = \"tripod\", walkMode = \"walking\") => {\n  const {\n    hipStance,\n    rx,\n    ry,\n    tx,\n    tz,\n    legStance\n  } = params;\n  const rawIKparams = {\n    tx,\n    ty: 0,\n    tz,\n    legStance,\n    hipStance,\n    rx,\n    ry,\n    rz: 0\n  };\n  const [ikSolver] = Object(_ik_hexapodSolver__WEBPACK_IMPORTED_MODULE_0__[\"solveHexapodParams\"])(dimensions, rawIKparams, true);\n\n  if (!ikSolver.foundSolution || ikSolver.hasLegsOffGround) {\n    return null;\n  }\n\n  const {\n    hipSwing,\n    liftSwing,\n    stepCount\n  } = params;\n  const [aHipSwing, aLiftSwing] = [Math.abs(hipSwing), Math.abs(liftSwing)];\n  const hipSwings = walkMode === \"rotating\" ? getHipSwingRotate(aHipSwing) : getHipSwingForward(aHipSwing);\n  return gaitType === \"ripple\" ? rippleSequence(ikSolver.pose, aLiftSwing, hipSwings, stepCount) : tripodSequence(ikSolver.pose, aLiftSwing, hipSwings, stepCount);\n};\n/* *\n\npowerStroke aka stancePhase\nreturnStroke aka swingPhase\n\n1. > startPowerStroke / endReturnStroke < 6.\n\n       \\\n        \\\n         *--*--*\n        /   |   \\   /\n       * -- * -- * /\n      \\ \\   |   /\n       \\ *--*--*\n\n2. > middlePowerStroke / middleReturnStroke < 5.\n\n     --- *--*--*\n        /   |   \\\n       * -- * -- * ---\n        \\   |   /\n    ---- *--*--*\n\n3. > endPowerStroke / startReturnStroke < 4.\n\n       / *--*--*\n      / /   |   \\\n       * -- * -- *\n        \\   |   / \\\n         *--*--*   \\\n       /\n      /\n\n TRIPOD1 - leftFront, rightMiddle, leftBack\n\n |----- powerStroke ----------|------- returnStroke -------|\n                              |-- liftUp --|-- shoveDown --|\n\n TRIPOD2 rightFront, leftMiddle, rightBack\n\n |------- returnStroke -------|----- powerStroke ----------|\n |-- liftUp --|-- shoveDown --|\n\n * */\n\n\nconst tripodSequence = (pose, aLiftSwing, hipSwings, stepCount, walkMode) => {\n  const {\n    forwardAlphaSeqs,\n    liftBetaSeqs,\n    liftGammaSeqs\n  } = buildTripodSequences(pose, aLiftSwing, hipSwings, stepCount, walkMode);\n  const doubleStepCount = 2 * stepCount;\n  const tripodA = tripodASequence(forwardAlphaSeqs, liftGammaSeqs, liftBetaSeqs, doubleStepCount);\n  const tripodB = tripodBSequence(forwardAlphaSeqs, liftGammaSeqs, liftBetaSeqs, doubleStepCount);\n  return { ...tripodA,\n    ...tripodB\n  };\n};\n\nconst tripodASequence = (forwardAlphaSeqs, liftGammaSeqs, liftBetaSeqs, doubleStepCount) => [\"leftFront\", \"rightMiddle\", \"leftBack\"].reduce((sequences, legPosition) => {\n  const forward = forwardAlphaSeqs[legPosition];\n  const gammaLiftUp = liftGammaSeqs[legPosition];\n  const betaLiftUp = liftBetaSeqs[legPosition];\n  const gammaSeq = [...gammaLiftUp, ...gammaLiftUp.slice().reverse(), ...fillArray(gammaLiftUp[0], doubleStepCount)];\n  const betaSeq = [...betaLiftUp, ...betaLiftUp.slice().reverse(), ...fillArray(betaLiftUp[0], doubleStepCount)];\n  sequences[legPosition] = {\n    alpha: [...forward, ...forward.slice().reverse()],\n    gamma: gammaSeq,\n    beta: betaSeq\n  };\n  return sequences;\n}, {});\n\nconst tripodBSequence = (forwardAlphaSeqs, liftGammaSeqs, liftBetaSeqs, doubleStepCount) => [\"rightFront\", \"leftMiddle\", \"rightBack\"].reduce((sequences, legPosition) => {\n  const forward = forwardAlphaSeqs[legPosition];\n  const gammaLiftUp = liftGammaSeqs[legPosition];\n  const betaLiftUp = liftBetaSeqs[legPosition];\n  const gammaSeq = [...fillArray(gammaLiftUp[0], doubleStepCount), ...gammaLiftUp, ...gammaLiftUp.slice().reverse()];\n  const betaSeq = [...fillArray(betaLiftUp[0], doubleStepCount), ...betaLiftUp, ...betaLiftUp.slice().reverse()];\n  sequences[legPosition] = {\n    alpha: [...forward.slice().reverse(), ...forward],\n    gamma: gammaSeq,\n    beta: betaSeq\n  };\n  return sequences;\n}, {});\n/* * *\n\nRIPPLE SEQUENCE\na - lift-up\nb - shove-down\n[1, 2, 3, 4] - retract / power stroke sequence\n\nleft-back     |-- a --|-- b --|   1   |   2   |   3   |   4   |\nleft-middle   |   3   |   4   |-- a --|-- b --|   1   |   2   |\nleft-front    |   1   |   2   |   3   |   4   |-- a --|-- b --|\nright-front   |   4   |-- a --|-- b --|   1   |   2   |   3   |\nright-back    |   1   |   2   |   3   |-- a --|-- b --|   4   |\nright-middle  |-- b --|   1   |   2   |   3   |   4   |-- a --|\n\n * * */\n\n\nconst rippleSequence = (startPose, aLiftSwing, hipSwings, stepCount) => {\n  const legPositions = Object.keys(startPose);\n  let sequences = {};\n  legPositions.forEach(position => {\n    const {\n      alpha,\n      beta,\n      gamma\n    } = startPose[position];\n    const betaLift = buildSequence(beta, aLiftSwing, stepCount);\n    const gammaLift = buildSequence(gamma, -aLiftSwing / 2, stepCount);\n    const delta = hipSwings[position];\n    const fw1 = buildSequence(alpha - delta, delta, stepCount);\n    const fw2 = buildSequence(alpha, delta, stepCount);\n    const halfDelta = delta / 2;\n    const bk1 = buildSequence(alpha + delta, -halfDelta, stepCount);\n    const bk2 = buildSequence(alpha + halfDelta, -halfDelta, stepCount);\n    const bk3 = buildSequence(alpha, -halfDelta, stepCount);\n    const bk4 = buildSequence(alpha - halfDelta, -halfDelta, stepCount); // prettier-ignore\n\n    sequences[position] = buildRippleLegSequence(position, betaLift, gammaLift, fw1, fw2, bk1, bk2, bk3, bk4);\n  });\n  return sequences;\n};\n\nconst buildRippleLegSequence = (position, bLift, gLift, fw1, fw2, bk1, bk2, bk3, bk4) => {\n  const stepCount = fw1.length;\n  const revGLift = gLift.slice().reverse();\n  const revBLift = bLift.slice().reverse();\n  const b0 = bLift[0];\n  const g0 = gLift[0]; // n stands for neutral\n\n  const bN = fillArray(b0, stepCount);\n  const gN = fillArray(g0, stepCount);\n  const alphaSeq = [fw1, fw2, bk1, bk2, bk3, bk4];\n  const betaSeq = [bLift, revBLift, bN, bN, bN, bN];\n  const gammaSeq = [gLift, revGLift, gN, gN, gN, gN];\n  const moduloMap = {\n    leftBack: 0,\n    rightFront: 1,\n    leftMiddle: 2,\n    rightBack: 3,\n    leftFront: 4,\n    rightMiddle: 5\n  };\n  return {\n    alpha: modSequence(moduloMap[position], alphaSeq),\n    beta: modSequence(moduloMap[position], betaSeq),\n    gamma: modSequence(moduloMap[position], gammaSeq)\n  };\n};\n\nconst modSequence = (mod, seq) => {\n  const sequence = [...seq, ...seq];\n  return sequence.slice(mod, mod + 6).flat();\n};\n\nconst buildTripodSequences = (startPose, aLiftSwing, hipSwings, stepCount, walkMode) => {\n  const doubleStepCount = 2 * stepCount;\n  const legPositions = Object.keys(startPose);\n  let forwardAlphaSeqs = {};\n  let liftBetaSeqs = {};\n  let liftGammaSeqs = {};\n  legPositions.forEach(legPosition => {\n    const {\n      alpha,\n      beta,\n      gamma\n    } = startPose[legPosition];\n    const deltaAlpha = hipSwings[legPosition];\n    forwardAlphaSeqs[legPosition] = buildSequence(alpha - deltaAlpha, 2 * deltaAlpha, doubleStepCount);\n    liftBetaSeqs[legPosition] = buildSequence(beta, aLiftSwing, stepCount);\n    liftGammaSeqs[legPosition] = buildSequence(gamma, -aLiftSwing / 2, stepCount);\n  });\n  return {\n    forwardAlphaSeqs,\n    liftBetaSeqs,\n    liftGammaSeqs\n  };\n};\n\nconst buildSequence = (startVal, delta, stepCount) => {\n  const step = delta / stepCount;\n  let currentItem = startVal;\n  let array = [];\n\n  for (let i = 0; i < stepCount; i++) {\n    currentItem += step;\n    array.push(currentItem);\n  }\n\n  return array;\n};\n\nconst getHipSwingForward = aHipSwing => {\n  return {\n    leftFront: -aHipSwing,\n    rightMiddle: aHipSwing,\n    leftBack: -aHipSwing,\n    rightFront: aHipSwing,\n    leftMiddle: -aHipSwing,\n    rightBack: aHipSwing\n  };\n};\n\nconst getHipSwingRotate = aHipSwing => {\n  return {\n    leftFront: aHipSwing,\n    rightMiddle: aHipSwing,\n    leftBack: aHipSwing,\n    rightFront: aHipSwing,\n    leftMiddle: aHipSwing,\n    rightBack: aHipSwing\n  };\n};\n\nconst fillArray = (value, len) => {\n  if (len === 0) {\n    return [];\n  }\n\n  let a = [value];\n\n  while (a.length * 2 <= len) {\n    a = a.concat(a);\n  }\n\n  if (a.length < len) {\n    a = a.concat(a.slice(0, len - a.length));\n  }\n\n  return a;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (getWalkSequence);\n\n//# sourceURL=webpack://hexapod/./src/hexapod/solvers/walkSequenceSolver.js?");

/***/ }),

/***/ "./src/templates/hexapodParams.js":
/*!****************************************!*\
  !*** ./src/templates/hexapodParams.js ***!
  \****************************************/
/*! exports provided: DEFAULT_DIMENSIONS, DEFAULT_LEG_DIMENSIONS, DEFAULT_BODY_DIMENSIONS, DEFAULT_POSE, DEFAULT_IK_PARAMS, DEFAULT_PATTERN_PARAMS, DEFAULT_GAIT_PARAMS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_DIMENSIONS\", function() { return DEFAULT_DIMENSIONS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_LEG_DIMENSIONS\", function() { return DEFAULT_LEG_DIMENSIONS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_BODY_DIMENSIONS\", function() { return DEFAULT_BODY_DIMENSIONS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_POSE\", function() { return DEFAULT_POSE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_IK_PARAMS\", function() { return DEFAULT_IK_PARAMS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_PATTERN_PARAMS\", function() { return DEFAULT_PATTERN_PARAMS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_GAIT_PARAMS\", function() { return DEFAULT_GAIT_PARAMS; });\nconst DEFAULT_BODY_DIMENSIONS = {\n  front: 100,\n  side: 100,\n  middle: 100\n};\nconst DEFAULT_LEG_DIMENSIONS = {\n  coxia: 100,\n  femur: 100,\n  tibia: 100\n};\nconst DEFAULT_DIMENSIONS = {\n  front: 100,\n  side: 100,\n  middle: 100,\n  coxia: 100,\n  femur: 100,\n  tibia: 100\n};\nconst DEFAULT_POSE = {\n  leftFront: {\n    alpha: 0,\n    beta: 0,\n    gamma: 0\n  },\n  rightFront: {\n    alpha: 0,\n    beta: 0,\n    gamma: 0\n  },\n  leftMiddle: {\n    alpha: 0,\n    beta: 0,\n    gamma: 0\n  },\n  rightMiddle: {\n    alpha: 0,\n    beta: 0,\n    gamma: 0\n  },\n  leftBack: {\n    alpha: 0,\n    beta: 0,\n    gamma: 0\n  },\n  rightBack: {\n    alpha: 0,\n    beta: 0,\n    gamma: 0\n  }\n};\nconst DEFAULT_PATTERN_PARAMS = {\n  alpha: 0,\n  beta: 0,\n  gamma: 0\n};\nconst DEFAULT_IK_PARAMS = {\n  tx: 0,\n  ty: 0,\n  tz: 0,\n  rx: 0,\n  ry: 0,\n  rz: 0,\n  hipStance: 0,\n  legStance: 0\n};\nconst DEFAULT_GAIT_PARAMS = {\n  tx: 0,\n  tz: 0,\n  rx: 0,\n  ry: 0,\n  legStance: 0,\n  hipStance: 20,\n  hipSwing: 25,\n  liftSwing: 40,\n  stepCount: 5\n};\n\n\n//# sourceURL=webpack://hexapod/./src/templates/hexapodParams.js?");

/***/ }),

/***/ "./src/templates/index.js":
/*!********************************!*\
  !*** ./src/templates/index.js ***!
  \********************************/
/*! exports provided: DEFAULT_DIMENSIONS, DEFAULT_LEG_DIMENSIONS, DEFAULT_BODY_DIMENSIONS, DEFAULT_POSE, DEFAULT_PATTERN_PARAMS, DEFAULT_GAIT_PARAMS, DEFAULT_IK_PARAMS, DATA, LAYOUT, DATA_INDEX_MAP, SCENE, CAMERA_VIEW */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _hexapodParams__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hexapodParams */ \"./src/templates/hexapodParams.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_DIMENSIONS\", function() { return _hexapodParams__WEBPACK_IMPORTED_MODULE_0__[\"DEFAULT_DIMENSIONS\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_LEG_DIMENSIONS\", function() { return _hexapodParams__WEBPACK_IMPORTED_MODULE_0__[\"DEFAULT_LEG_DIMENSIONS\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_BODY_DIMENSIONS\", function() { return _hexapodParams__WEBPACK_IMPORTED_MODULE_0__[\"DEFAULT_BODY_DIMENSIONS\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_POSE\", function() { return _hexapodParams__WEBPACK_IMPORTED_MODULE_0__[\"DEFAULT_POSE\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_PATTERN_PARAMS\", function() { return _hexapodParams__WEBPACK_IMPORTED_MODULE_0__[\"DEFAULT_PATTERN_PARAMS\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_GAIT_PARAMS\", function() { return _hexapodParams__WEBPACK_IMPORTED_MODULE_0__[\"DEFAULT_GAIT_PARAMS\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_IK_PARAMS\", function() { return _hexapodParams__WEBPACK_IMPORTED_MODULE_0__[\"DEFAULT_IK_PARAMS\"]; });\n\n/* harmony import */ var _plotParams__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plotParams */ \"./src/templates/plotParams.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DATA\", function() { return _plotParams__WEBPACK_IMPORTED_MODULE_1__[\"DATA\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LAYOUT\", function() { return _plotParams__WEBPACK_IMPORTED_MODULE_1__[\"LAYOUT\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DATA_INDEX_MAP\", function() { return _plotParams__WEBPACK_IMPORTED_MODULE_1__[\"DATA_INDEX_MAP\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SCENE\", function() { return _plotParams__WEBPACK_IMPORTED_MODULE_1__[\"SCENE\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CAMERA_VIEW\", function() { return _plotParams__WEBPACK_IMPORTED_MODULE_1__[\"CAMERA_VIEW\"]; });\n\n\n\n\n\n//# sourceURL=webpack://hexapod/./src/templates/index.js?");

/***/ }),

/***/ "./src/templates/plotParams.js":
/*!*************************************!*\
  !*** ./src/templates/plotParams.js ***!
  \*************************************/
/*! exports provided: DATA, LAYOUT, DATA_INDEX_MAP, SCENE, CAMERA_VIEW */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DATA\", function() { return DATA; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LAYOUT\", function() { return LAYOUT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DATA_INDEX_MAP\", function() { return DATA_INDEX_MAP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SCENE\", function() { return SCENE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CAMERA_VIEW\", function() { return CAMERA_VIEW; });\nconst BODY_MESH_COLOR = \"#ff6348\";\nconst BODY_COLOR = \"#FC427B\";\nconst COG_COLOR = \"#32ff7e\";\nconst LEG_COLOR = \"#EE5A24\";\nconst SUPPORT_POLYGON_MESH_COLOR = \"#3c6382\";\nconst AXIS_ZERO_LINE_COLOR = \"#079992\";\nconst PAPER_BG_COLOR = \"rgb(23, 33, 43)\";\nconst GROUND_COLOR = \"rgb(14, 40, 69)\";\nconst LEGEND_FONT_COLOR = \"#2ecc71\";\nconst LEGENDS_BG_COLOR = \"rgba(44, 62, 80, 0.8)\";\nconst BODY_MESH_OPACITY = 0.3;\nconst BODY_OUTLINE_WIDTH = 12;\nconst COG_SIZE = 14;\nconst HEAD_SIZE = 14;\nconst LEG_OUTLINE_WIDTH = 10;\nconst SUPPORT_POLYGON_MESH_OPACITY = 0.2;\nconst DATA_INDEX_MAP = {\n  bodyMesh: 0,\n  bodyOutline: 1,\n  head: 2,\n  centerOfGravity: 3,\n  centerOfGravityProjection: 4,\n  rightMiddleLeg: 5,\n  rightFrontLeg: 6,\n  leftFrontLeg: 7,\n  leftMiddleLeg: 8,\n  leftBackLeg: 9,\n  rightBackLeg: 10,\n  supportPolygonMesh: 11,\n  hexapodXaxis: 12,\n  hexapodYaxis: 13,\n  hexapodZaxis: 14,\n  worldXaxis: 15,\n  worldYaxis: 16,\n  worldZaxis: 17\n};\nconst DATA = [{\n  name: \"bodyMesh\",\n  showlegend: true,\n  type: \"mesh3d\",\n  opacity: BODY_MESH_OPACITY,\n  color: BODY_MESH_COLOR,\n  x: [100.0, 100.0, -100.0, -100.0, -100.0, 100.0, 100.0],\n  y: [0.0, 100.0, 100.0, 0.0, -100.0, -100.0, 0.0],\n  z: [100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0]\n}, {\n  line: {\n    color: BODY_COLOR,\n    opacity: 1.0,\n    width: BODY_OUTLINE_WIDTH\n  },\n  name: \"bodyOutline\",\n  showlegend: true,\n  type: \"scatter3d\",\n  x: [100.0, 100.0, -100.0, -100.0, -100.0, 100.0, 100.0],\n  y: [0.0, 100.0, 100.0, 0.0, -100.0, -100.0, 0.0],\n  z: [100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0]\n}, {\n  marker: {\n    color: BODY_COLOR,\n    opacity: 1.0,\n    size: HEAD_SIZE\n  },\n  mode: \"markers\",\n  name: \"head\",\n  type: \"scatter3d\",\n  x: [0.0],\n  y: [100.0],\n  z: [100.0]\n}, {\n  marker: {\n    color: COG_COLOR,\n    opacity: 1,\n    size: COG_SIZE\n  },\n  mode: \"markers\",\n  name: \"centerOfGravity\",\n  type: \"scatter3d\",\n  x: [0.0],\n  y: [0.0],\n  z: [100.0]\n}, {\n  marker: {\n    color: COG_COLOR,\n    opacity: 0.5,\n    size: 0.5 * COG_SIZE\n  },\n  mode: \"markers\",\n  name: \"centerOfGravityProjection\",\n  type: \"scatter3d\",\n  x: [0.0],\n  y: [0.0],\n  z: [0.0]\n}, {\n  line: {\n    color: LEG_COLOR,\n    width: LEG_OUTLINE_WIDTH\n  },\n  name: \"rightMiddleLeg\",\n  showlegend: false,\n  type: \"scatter3d\",\n  x: [100.0, 200.0, 300.0, 300.0],\n  y: [0.0, 0.0, 0.0, 0.0],\n  z: [100.0, 100.0, 100.0, 0.0]\n}, {\n  line: {\n    color: LEG_COLOR,\n    width: LEG_OUTLINE_WIDTH\n  },\n  name: \"rightFrontLeg\",\n  showlegend: false,\n  type: \"scatter3d\",\n  x: [100.0, 170.71067811865476, 241.4213562373095, 241.4213562373095],\n  y: [100.0, 170.71067811865476, 241.42135623730948, 241.42135623730948],\n  z: [100.0, 100.0, 100.0, 0.0]\n}, {\n  line: {\n    color: LEG_COLOR,\n    width: LEG_OUTLINE_WIDTH\n  },\n  name: \"leftFrontLeg\",\n  showlegend: false,\n  type: \"scatter3d\",\n  x: [-100.0, -170.71067811865476, -241.42135623730948, -241.42135623730948],\n  y: [100.0, 170.71067811865476, 241.4213562373095, 241.4213562373095],\n  z: [100.0, 100.0, 100.0, 0.0]\n}, {\n  line: {\n    color: LEG_COLOR,\n    width: LEG_OUTLINE_WIDTH\n  },\n  name: \"leftMiddleLeg\",\n  showlegend: false,\n  type: \"scatter3d\",\n  x: [-100.0, -200.0, -300.0, -300.0],\n  y: [0.0, 1.2246467991473532e-14, 2.4492935982947064e-14, 2.4492935982947064e-14],\n  z: [100.0, 100.0, 100.0, 0.0]\n}, {\n  line: {\n    color: LEG_COLOR,\n    width: LEG_OUTLINE_WIDTH\n  },\n  name: \"leftBackLeg\",\n  showlegend: false,\n  type: \"scatter3d\",\n  x: [-100.0, -170.71067811865476, -241.42135623730954, -241.42135623730954],\n  y: [-100.0, -170.71067811865476, -241.42135623730948, -241.42135623730948],\n  z: [100.0, 100.0, 100.0, 0.0]\n}, {\n  line: {\n    color: LEG_COLOR,\n    width: LEG_OUTLINE_WIDTH\n  },\n  name: \"rightBackLeg\",\n  showlegend: false,\n  type: \"scatter3d\",\n  x: [100.0, 170.71067811865476, 241.42135623730948, 241.42135623730948],\n  y: [-100.0, -170.71067811865476, -241.42135623730954, -241.42135623730954],\n  z: [100.0, 100.0, 100.0, 0.0]\n}, {\n  name: \"supportPolygonMesh\",\n  showlegend: true,\n  type: \"mesh3d\",\n  opacity: SUPPORT_POLYGON_MESH_OPACITY,\n  color: SUPPORT_POLYGON_MESH_COLOR,\n  x: [300.0, 241.4213562373095, -241.42135623730948, -300.0, -241.42135623730954, 241.42135623730948],\n  y: [0.0, 241.42135623730948, 241.4213562373095, 2.4492935982947064e-14, -241.42135623730948, -241.42135623730954],\n  z: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n}, {\n  line: {\n    color: \"#2f3640\",\n    width: 2\n  },\n  name: \"hexapodXaxis\",\n  mode: \"lines\",\n  showlegend: false,\n  opacity: 1.0,\n  type: \"scatter3d\",\n  x: [0.0, 50.0],\n  y: [0.0, 0.0],\n  z: [100.0, 100.0]\n}, {\n  line: {\n    color: \"#e67e22\",\n    width: 2\n  },\n  name: \"hexapodYaxis\",\n  mode: \"lines\",\n  showlegend: false,\n  opacity: 1.0,\n  type: \"scatter3d\",\n  x: [0.0, 0.0],\n  y: [0.0, 50.0],\n  z: [100.0, 100.0]\n}, {\n  line: {\n    color: \"#0097e6\",\n    width: 2\n  },\n  name: \"hexapodZaxis\",\n  mode: \"lines\",\n  showlegend: false,\n  opacity: 1.0,\n  type: \"scatter3d\",\n  x: [0.0, 0.0],\n  y: [0.0, 0.0],\n  z: [100.0, 150.0]\n}, {\n  line: {\n    color: \"#2f3640\",\n    width: 2\n  },\n  name: \"worldXaxis\",\n  showlegend: false,\n  mode: \"lines\",\n  opacity: 1.0,\n  type: \"scatter3d\",\n  x: [0, 50],\n  y: [0, 0],\n  z: [0, 0]\n}, {\n  line: {\n    color: \"#e67e22\",\n    width: 2\n  },\n  name: \"worldYaxis\",\n  showlegend: false,\n  mode: \"lines\",\n  opacity: 1.0,\n  type: \"scatter3d\",\n  x: [0, 0],\n  y: [0, 50],\n  z: [0, 0]\n}, {\n  line: {\n    color: \"#0097e6\",\n    width: 2\n  },\n  name: \"worldZaxis\",\n  showlegend: false,\n  mode: \"lines\",\n  opacity: 1.0,\n  type: \"scatter3d\",\n  x: [0, 0],\n  y: [0, 0],\n  z: [0, 50]\n}];\nconst CAMERA_VIEW = {\n  center: {\n    x: 0.0005967195135552272,\n    y: 0.11455181630825005,\n    z: -0.44957387699746415\n  },\n  eye: {\n    x: 0.010119765679525836,\n    y: 0.573601223004958,\n    z: 0.04247372257492105\n  },\n  up: {\n    x: 0.006592638138864914,\n    y: 0.00003338632363222382,\n    z: 0.9999782677677168\n  }\n};\nconst SCENE = {\n  xaxis: {\n    nticks: 1,\n    range: [-600, 600],\n    zerolinecolor: AXIS_ZERO_LINE_COLOR,\n    showbackground: false\n  },\n  yaxis: {\n    nticks: 1,\n    range: [-600, 600],\n    zerolinecolor: AXIS_ZERO_LINE_COLOR,\n    showbackground: false\n  },\n  zaxis: {\n    nticks: 1,\n    range: [-10, 590],\n    zerolinecolor: AXIS_ZERO_LINE_COLOR,\n    showbackground: true,\n    backgroundcolor: GROUND_COLOR\n  },\n  aspectmode: \"manual\",\n  aspectratio: {\n    x: 1,\n    y: 1,\n    z: 1\n  },\n  camera: CAMERA_VIEW\n};\nconst LAYOUT = {\n  scene: SCENE,\n  margin: {\n    b: 20,\n    l: 10,\n    r: 10,\n    t: 20\n  },\n  paper_bgcolor: PAPER_BG_COLOR,\n  legend: {\n    x: 0,\n    y: 0,\n    bgcolor: LEGENDS_BG_COLOR,\n    font: {\n      family: \"courier\",\n      size: 12,\n      color: LEGEND_FONT_COLOR\n    }\n  },\n  showlegend: false,\n  autosize: true\n};\n\n\n//# sourceURL=webpack://hexapod/./src/templates/plotParams.js?");

/***/ }),

/***/ "./src/templates/plotter.js":
/*!**********************************!*\
  !*** ./src/templates/plotter.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ */ \"./src/templates/index.js\");\n\n\nconst _getSumOfDimensions = dimensions => Object.values(dimensions).reduce((sum, dimension) => sum + dimension, 0);\n\nconst _drawHexapod = hexapod => {\n  const polygonVertices = hexapod.body.closedPointsList;\n  const bodyX = polygonVertices.map(point => point.x);\n  const bodyY = polygonVertices.map(point => point.y);\n  const bodyZ = polygonVertices.map(point => point.z);\n  const {\n    head,\n    cog\n  } = hexapod.body;\n  const {\n    cogProjection,\n    legs,\n    groundContactPoints\n  } = hexapod;\n  const dBodyMesh = { ...___WEBPACK_IMPORTED_MODULE_0__[\"DATA\"][0],\n    x: bodyX,\n    y: bodyY,\n    z: bodyZ\n  };\n  const dBodyOutline = { ...___WEBPACK_IMPORTED_MODULE_0__[\"DATA\"][1],\n    x: bodyX,\n    y: bodyY,\n    z: bodyZ\n  };\n  const dHead = { ...___WEBPACK_IMPORTED_MODULE_0__[\"DATA\"][2],\n    x: [head.x],\n    y: [head.y],\n    z: [head.z]\n  };\n  const dCog = { ...___WEBPACK_IMPORTED_MODULE_0__[\"DATA\"][3],\n    x: [cog.x],\n    y: [cog.y],\n    z: [cog.z]\n  };\n  const dCogProjection = { ...___WEBPACK_IMPORTED_MODULE_0__[\"DATA\"][4],\n    x: [cogProjection.x],\n    y: [cogProjection.y],\n    z: [cogProjection.z]\n  };\n  const dLegs = legs.map((leg, index) => ({ ...___WEBPACK_IMPORTED_MODULE_0__[\"DATA\"][index + 5],\n    x: leg.allPointsList.map(point => point.x),\n    y: leg.allPointsList.map(point => point.y),\n    z: leg.allPointsList.map(point => point.z)\n  }));\n  const dSupportPolygon = { ...___WEBPACK_IMPORTED_MODULE_0__[\"DATA\"][11],\n    x: groundContactPoints.map(point => point.x),\n    y: groundContactPoints.map(point => point.y),\n    z: groundContactPoints.map(point => point.z)\n  };\n  const axisScale = hexapod.body.dimensions.front / 2;\n  const {\n    xAxis,\n    yAxis,\n    zAxis\n  } = hexapod.localAxes;\n  const hXaxis = { ...___WEBPACK_IMPORTED_MODULE_0__[\"DATA\"][12],\n    x: [cog.x, cog.x + axisScale * xAxis.x],\n    y: [cog.y, cog.y + axisScale * xAxis.y],\n    z: [cog.z, cog.z + axisScale * xAxis.z]\n  };\n  const hYaxis = { ...___WEBPACK_IMPORTED_MODULE_0__[\"DATA\"][13],\n    x: [cog.x, cog.x + axisScale * yAxis.x],\n    y: [cog.y, cog.y + axisScale * yAxis.y],\n    z: [cog.z, cog.z + axisScale * yAxis.z]\n  };\n  const hZaxis = { ...___WEBPACK_IMPORTED_MODULE_0__[\"DATA\"][14],\n    x: [cog.x, cog.x + axisScale * zAxis.x],\n    y: [cog.y, cog.y + axisScale * zAxis.y],\n    z: [cog.z, cog.z + axisScale * zAxis.z]\n  };\n  const wXaxis = { ...___WEBPACK_IMPORTED_MODULE_0__[\"DATA\"][15],\n    x: [0, axisScale]\n  };\n  const wYaxis = { ...___WEBPACK_IMPORTED_MODULE_0__[\"DATA\"][16],\n    y: [0, axisScale]\n  };\n  const wZaxis = { ...___WEBPACK_IMPORTED_MODULE_0__[\"DATA\"][17],\n    z: [0, axisScale]\n  };\n  return [dBodyMesh, dBodyOutline, dHead, dCog, dCogProjection, ...dLegs, dSupportPolygon, hXaxis, hYaxis, hZaxis, wXaxis, wYaxis, wZaxis];\n};\n\nconst getNewPlotParams = (hexapod, cameraView) => {\n  const data = _drawHexapod(hexapod);\n\n  if ([null, undefined, {}].includes(cameraView)) {\n    cameraView = ___WEBPACK_IMPORTED_MODULE_0__[\"CAMERA_VIEW\"];\n  }\n\n  const range = _getSumOfDimensions(hexapod.dimensions);\n\n  const newRange = [-range, range];\n  const xaxis = { ...___WEBPACK_IMPORTED_MODULE_0__[\"SCENE\"].xaxis,\n    range: newRange\n  };\n  const yaxis = { ...___WEBPACK_IMPORTED_MODULE_0__[\"SCENE\"].yaxis,\n    range: newRange\n  };\n  const zaxis = { ...___WEBPACK_IMPORTED_MODULE_0__[\"SCENE\"].zaxis,\n    range: [-10, 2 * range - 10]\n  };\n  const scene = { ...___WEBPACK_IMPORTED_MODULE_0__[\"SCENE\"],\n    xaxis,\n    yaxis,\n    zaxis,\n    camera: cameraView\n  };\n  const layout = { ...___WEBPACK_IMPORTED_MODULE_0__[\"LAYOUT\"],\n    scene\n  };\n  return [data, layout];\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (getNewPlotParams);\n\n//# sourceURL=webpack://hexapod/./src/templates/plotter.js?");

/***/ }),

/***/ "./src/templates/vars.js":
/*!*******************************!*\
  !*** ./src/templates/vars.js ***!
  \*******************************/
/*! exports provided: LANDING_PAGE_MESSAGE, SECTION_NAMES, ANGLE_NAMES, DIMENSION_NAMES, LEG_NAMES, IK_SLIDERS_LABELS, GAIT_SLIDER_LABELS, RESET_LABEL, RANGE_PARAMS, GAIT_RANGE_PARAMS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LANDING_PAGE_MESSAGE\", function() { return LANDING_PAGE_MESSAGE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SECTION_NAMES\", function() { return SECTION_NAMES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ANGLE_NAMES\", function() { return ANGLE_NAMES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DIMENSION_NAMES\", function() { return DIMENSION_NAMES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LEG_NAMES\", function() { return LEG_NAMES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IK_SLIDERS_LABELS\", function() { return IK_SLIDERS_LABELS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GAIT_SLIDER_LABELS\", function() { return GAIT_SLIDER_LABELS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RESET_LABEL\", function() { return RESET_LABEL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RANGE_PARAMS\", function() { return RANGE_PARAMS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GAIT_RANGE_PARAMS\", function() { return GAIT_RANGE_PARAMS; });\n// import React from \"react\"\n// import { GiCoffeeMug } from \"react-icons/gi\"\n// import { FaGithubAlt, FaTimes, FaHome } from \"react-icons/fa\"\n// import { GrStatusGoodSmall } from \"react-icons/gr\"\nconst SECTION_NAMES = {\n  dimensions: \"Dimensions\",\n  inverseKinematics: \"Inverse Kinematics\",\n  forwardKinematics: \"Forward Kinematics\",\n  legPatterns: \"Leg Patterns\",\n  landingPage: \"Root\",\n  walkingGaits: \"Walking Gaits\"\n};\nconst PATH_NAMES = {\n  inverseKinematics: \"/inverse-kinematics\",\n  forwardKinematics: \"/forward-kinematics\",\n  legPatterns: \"/leg-patterns\",\n  landingPage: \"/\",\n  walkingGaits: \"/walking-gaits\"\n};\nconst ANGLE_NAMES = [\"alpha\", \"beta\", \"gamma\"];\nconst DIMENSION_NAMES = [\"front\", \"side\", \"middle\", \"coxia\", \"femur\", \"tibia\"];\nconst LEG_NAMES = [\"leftFront\", \"rightFront\", \"leftMiddle\", \"rightMiddle\", \"leftBack\", \"rightBack\"];\nconst IK_SLIDERS_LABELS = [\"tx\", \"ty\", \"tz\", \"rx\", \"ry\", \"rz\", \"hipStance\", \"legStance\"];\nconst RESET_LABEL = \"reset\";\nconst GAIT_SLIDER_LABELS = [\"hipSwing\", \"liftSwing\", \"legStance\", \"hipStance\", \"tx\", \"tz\", \"rx\", \"ry\", \"stepCount\"];\n/*************\n * RANGE PARAMS\n *************/\n\nconst rangeParams = absVal => ({\n  minVal: -absVal,\n  maxVal: absVal,\n  stepVal: 0.01\n});\n\nconst RANGES = {\n  30: rangeParams(30),\n  45: rangeParams(45),\n  60: rangeParams(60),\n  90: rangeParams(90),\n  180: rangeParams(180)\n};\nconst translateInputs = {\n  minVal: -1,\n  maxVal: 1,\n  stepVal: 0.01\n};\nconst RANGE_PARAMS = {\n  dimensionInputs: {\n    minVal: 0,\n    maxVal: Infinity,\n    stepVal: 1\n  },\n  tx: translateInputs,\n  ty: translateInputs,\n  tz: translateInputs,\n  rx: RANGES[30],\n  ry: RANGES[30],\n  rz: RANGES[60],\n  legStance: RANGES[90],\n  hipStance: RANGES[60],\n  alpha: RANGES[90],\n  beta: RANGES[180],\n  gamma: RANGES[180]\n};\nconst GAIT_RANGE_PARAMS = {\n  tx: {\n    minVal: -0.25,\n    maxVal: 0.25,\n    stepVal: 0.01,\n    defaultVal: 0\n  },\n  tz: {\n    minVal: -0.5,\n    maxVal: 0.5,\n    stepVal: 0.01,\n    defaultVal: 0\n  },\n  rx: {\n    minVal: -15,\n    maxVal: 15,\n    stepVal: 0.5,\n    defaultVal: 0\n  },\n  ry: {\n    minVal: -15,\n    maxVal: 15,\n    stepVal: 0.5,\n    defaultVal: 0\n  },\n  legStance: {\n    minVal: -50,\n    maxVal: 50,\n    stepVal: 0.5,\n    defaultVal: 0\n  },\n  hipStance: {\n    minVal: 0,\n    maxVal: 40,\n    stepVal: 0.5,\n    defaultVal: 20\n  },\n  hipSwing: {\n    minVal: 10,\n    maxVal: 40,\n    stepVal: 0.5,\n    defaultVal: 25\n  },\n  liftSwing: {\n    minVal: 10,\n    maxVal: 70,\n    stepVal: 0.5,\n    defaultVal: 40\n  },\n  stepCount: {\n    minVal: 3,\n    maxVal: 7,\n    stepVal: 1,\n    defaultVal: 5\n  }\n};\n/*************\n * LANDING PAGE\n *************/\n\nconst LANDING_PAGE_MESSAGE = `\n\n# Mithi's Bare Minimum Hexapod Robot Simulator\n\nEnjoy your stay and share with your friends!\n`;\n\n\n//# sourceURL=webpack://hexapod/./src/templates/vars.js?");

/***/ }),

/***/ "./src/walkingGaits.js":
/*!*****************************!*\
  !*** ./src/walkingGaits.js ***!
  \*****************************/
/*! exports provided: WalkingGaits */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WalkingGaits\", function() { return WalkingGaits; });\n/* harmony import */ var _templates_vars__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./templates/vars */ \"./src/templates/vars.js\");\n/* harmony import */ var _hexapod_solvers_walkSequenceSolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hexapod/solvers/walkSequenceSolver */ \"./src/hexapod/solvers/walkSequenceSolver.js\");\n/* harmony import */ var _hexapod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hexapod */ \"./src/hexapod/index.js\");\n/* harmony import */ var _hexapod_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hexapod/geometry */ \"./src/hexapod/geometry.js\");\n/* harmony import */ var _templates__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./templates */ \"./src/templates/index.js\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// import React, { Component } from \"react\"\n// import { sliderList, Card, ResetButton, ToggleSwitch } from \"./generic\"\n\n // import PoseTable from \"./pagePartials/PoseTable\"\n\n\n\n // import * as ROSLIB from 'roslib'\n\nconst ANIMATION_DELAY = 25;\n\nconst getPose = (sequences, i) => {\n  return Object.keys(sequences).reduce((newSequences, legPosition) => {\n    const {\n      alpha,\n      beta,\n      gamma\n    } = sequences[legPosition];\n    newSequences[legPosition] = {\n      alpha: alpha[i],\n      beta: beta[i],\n      gamma: gamma[i]\n    };\n    return newSequences;\n  }, {});\n};\n\nconst newSwitch = (id, value, handleChange) => /*#__PURE__*/React.createElement(ToggleSwitch, {\n  id: id,\n  handleChange: handleChange,\n  value: value,\n  showValue: true\n});\n\nconst switches = (switch1, switch2, switch3) => /*#__PURE__*/React.createElement(\"div\", {\n  className: \"grid-cols-3\",\n  style: {\n    paddingBottom: \"20px\"\n  }\n}, switch1, switch2, switch3);\n\nconst countSteps = sequence => sequence[\"leftMiddle\"].alpha.length;\n\nclass WalkingGaits {\n  setState(obj) {\n    Object.assign(this.state, obj);\n  }\n\n  constructor(onHexapodUpdate = null, onAnimation = null) {\n    _defineProperty(this, \"pageName\", _templates_vars__WEBPACK_IMPORTED_MODULE_0__[\"SECTION_NAMES\"].walkingGaits);\n\n    _defineProperty(this, \"speed\", 0);\n\n    _defineProperty(this, \"currentTwist\", 0);\n\n    _defineProperty(this, \"walkSequence\", null);\n\n    _defineProperty(this, \"startPress\", false);\n\n    _defineProperty(this, \"resetPress\", false);\n\n    _defineProperty(this, \"state\", {\n      gaitParams: _templates__WEBPACK_IMPORTED_MODULE_4__[\"DEFAULT_GAIT_PARAMS\"],\n      isAnimating: false,\n      isTripodGait: false,\n      isForward: true,\n      inWalkMode: true,\n      showGaitWidgets: true,\n      animationCount: 0\n    });\n\n    _defineProperty(this, \"props\", {\n      params: {\n        pose: _templates__WEBPACK_IMPORTED_MODULE_4__[\"DEFAULT_POSE\"],\n        dimensions: _templates__WEBPACK_IMPORTED_MODULE_4__[\"DEFAULT_DIMENSIONS\"]\n      },\n      onUpdate: () => {}\n    });\n\n    _defineProperty(this, \"componentDidMount\", () => {\n      // this.props.onMount(this.pageName)\n      const {\n        isTripodGait,\n        inWalkMode\n      } = this.state;\n      this.setWalkSequence(_templates__WEBPACK_IMPORTED_MODULE_4__[\"DEFAULT_GAIT_PARAMS\"], isTripodGait, inWalkMode);\n    });\n\n    _defineProperty(this, \"componentWillUnmount\", () => {\n      clearInterval(this.intervalID);\n    });\n\n    _defineProperty(this, \"animate\", () => {\n      if (this.onAnimation) {\n        if (this.onAnimation()) {} else {\n          return;\n        }\n      }\n\n      let {\n        isForward,\n        inWalkMode\n      } = this.state;\n      const stepCount = countSteps(this.walkSequence);\n      const animationCount = (this.state.animationCount + 1) % stepCount;\n      this.setState({\n        animationCount\n      });\n      const tempStep = isForward ? animationCount : stepCount - animationCount;\n      const step = Math.max(0, Math.min(stepCount - 1, tempStep));\n      const pose = getPose(this.walkSequence, step);\n\n      if (inWalkMode) {\n        this.onUpdate(pose, this.currentTwist);\n        return;\n      }\n\n      const deltaTwist = this.state.gaitParams.hipSwing * 2 / stepCount;\n      const twist = isForward ? (this.currentTwist + deltaTwist) % 360 : (this.currentTwist - deltaTwist) % 360;\n      this.onUpdate(pose, twist);\n    });\n\n    _defineProperty(this, \"onUpdate\", (pose, currentTwist) => {\n      this.currentTwist = currentTwist;\n      const {\n        dimensions\n      } = this.props.params;\n      const hexapod = new _hexapod__WEBPACK_IMPORTED_MODULE_2__[\"VirtualHexapod\"](dimensions, pose, {\n        wontRotate: true\n      }); // HACK When we've passed undefined pose values for some reason\n\n      if (!hexapod || !hexapod.body) {\n        return;\n      }\n\n      const matrix = Object(_hexapod_geometry__WEBPACK_IMPORTED_MODULE_3__[\"tRotZmatrix\"])(currentTwist);\n      let pod = hexapod.cloneTrot(matrix); // console.log('onUpdate', hexapod)\n\n      this.props.onUpdate(\"hexapod\", {\n        hexapod: pod\n      });\n\n      if (this.onHexapodUpdate) {\n        this.onHexapodUpdate(pod);\n      } // this.setLegAngles(hexapod.legs)\n\n    });\n\n    _defineProperty(this, \"setWalkSequence\", (gaitParams, isTripodGait, inWalkMode) => {\n      const gaitType = isTripodGait ? \"tripod\" : \"ripple\";\n      const walkMode = inWalkMode ? \"walking\" : \"rotating\";\n      const {\n        dimensions\n      } = this.props.params;\n      const {\n        animationCount\n      } = this.state;\n      this.walkSequence = Object(_hexapod_solvers_walkSequenceSolver__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(dimensions, gaitParams, gaitType, walkMode) || this.walkSequence;\n      const pose = getPose(this.walkSequence, animationCount);\n      this.onUpdate(pose, this.currentTwist);\n      this.setState({\n        gaitParams,\n        isTripodGait,\n        inWalkMode\n      });\n    });\n\n    _defineProperty(this, \"reset\", () => {\n      const {\n        isTripodGait,\n        inWalkMode\n      } = this.state;\n      this.currentTwist = 0;\n      this.setWalkSequence(_templates__WEBPACK_IMPORTED_MODULE_4__[\"DEFAULT_GAIT_PARAMS\"], isTripodGait, inWalkMode);\n    });\n\n    _defineProperty(this, \"updateGaitParams\", (name, value) => {\n      const {\n        isTripodGait,\n        inWalkMode\n      } = this.state;\n      const gaitParams = { ...this.state.gaitParams,\n        [name]: value\n      };\n      this.setWalkSequence(gaitParams, isTripodGait, inWalkMode);\n    });\n\n    _defineProperty(this, \"toggleWalkMode\", () => {\n      const {\n        gaitParams,\n        isTripodGait\n      } = this.state;\n      const inWalkMode = !this.state.inWalkMode;\n      this.setWalkSequence(gaitParams, isTripodGait, inWalkMode);\n    });\n\n    _defineProperty(this, \"toggleGaitType\", () => {\n      const {\n        gaitParams,\n        inWalkMode\n      } = this.state;\n      const isTripodGait = !this.state.isTripodGait;\n      this.setWalkSequence(gaitParams, isTripodGait, inWalkMode);\n    });\n\n    _defineProperty(this, \"toggleWidgets\", () => this.setState({\n      showGaitWidgets: !this.state.showGaitWidgets\n    }));\n\n    _defineProperty(this, \"toggleDirection\", () => this.setState({\n      isForward: !this.state.isForward\n    }));\n\n    _defineProperty(this, \"toggleAnimating\", () => {\n      const isAnimating = !this.state.isAnimating;\n      this.setState({\n        isAnimating\n      });\n\n      if (isAnimating) {\n        this.intervalID = setInterval(this.animate, ANIMATION_DELAY);\n      } else {\n        clearInterval(this.intervalID);\n      }\n    });\n\n    this.onHexapodUpdate = onHexapodUpdate;\n    this.onAnimation = onAnimation;\n    this.componentDidMount();\n  }\n  /*\n  get widgetsSwitch() {\n      const value = this.state.showGaitWidgets ? \"controlsShown\" : \"poseShown\"\n      return newSwitch(\"widgetSw\", value, this.toggleWidgets)\n  }\n   get animatingSwitch() {\n      const value = this.state.isAnimating ? \"PLAYING...\" : \"...PAUSED. \"\n      return newSwitch(\"animatingSw\", value, this.toggleAnimating)\n  }\n   get gaitTypeSwitch() {\n      const value = this.state.isTripodGait ? \"tripodGait\" : \"rippleGait\"\n      return newSwitch(\"gaitSw\", value, this.toggleGaitType)\n  }\n   get directionSwitch() {\n      const value = this.state.isForward ? \"isForward\" : \"isBackward\"\n      return newSwitch(\"directionSw\", value, this.toggleDirection)\n  }\n   get rotateSwitch() {\n      const value = this.state.inWalkMode ? \"isWalk\" : \"isRotate\"\n      return newSwitch(\"rotateSw\", value, this.toggleWalkMode)\n  }\n   get sliders() {\n      const sliders = sliderList({\n          names: GAIT_SLIDER_LABELS,\n          values: this.state.gaitParams,\n          rangeParams: GAIT_RANGE_PARAMS,\n          handleChange: this.updateGaitParams,\n      })\n       return <div className=\"grid-cols-2\">{sliders}</div>\n  }\n   get animationCount() {\n      const { isAnimating, animationCount } = this.state\n      return (\n          <div className=\"text\" hidden={!isAnimating}>\n              {animationCount}\n          </div>\n      )\n  }\n   render() {\n      const animationControlSwitches = switches(\n          this.animatingSwitch,\n          this.widgetsSwitch\n      )\n      const gaitControlSwitches = switches(\n          this.gaitTypeSwitch,\n          this.directionSwitch,\n          this.rotateSwitch\n      )\n       const { showGaitWidgets } = this.state\n      const { pose } = this.props.params\n       return (\n          <Card title={<h2>{this.pageName}</h2>} other={this.animationCount}>\n              {animationControlSwitches}\n               <div hidden={!showGaitWidgets}>\n                  {gaitControlSwitches}\n                  {this.sliders}\n                  <ResetButton reset={this.reset} />\n              </div>\n               <div hidden={showGaitWidgets}>\n                  <PoseTable pose={pose} />\n              </div>\n          </Card>\n      )\n  }\n  */\n\n\n}\n\n\n\n//# sourceURL=webpack://hexapod/./src/walkingGaits.js?");

/***/ })

/******/ });
});